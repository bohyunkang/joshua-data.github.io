<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2024-01-11T17:24:20+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Joshua Kim</title><subtitle>Data Analyst</subtitle><entry><title type="html">Data Warehouse #08</title><link href="http://localhost:4000/data-warehouse-08/" rel="alternate" type="text/html" title="Data Warehouse #08" /><published>2024-01-11T00:00:00+09:00</published><updated>2024-01-11T00:00:00+09:00</updated><id>http://localhost:4000/data-warehouse-08</id><content type="html" xml:base="http://localhost:4000/data-warehouse-08/"><![CDATA[<blockquote>
  <p>In this article, I’ll summarize key takeaways from:</p>
  <ul>
    <li>SECTION 07. Slowly Changing Dimensions</li>
  </ul>
</blockquote>

<h3 id="disclaimer">DISCLAIMER</h3>
<blockquote>
  <p>This article is a compilation of key takeaways after completing <a href="https://www.udemy.com/course/data-warehouse-the-ultimate-guide/">Data Warehouse — The Ultimate Guide</a> on Udemy. However, it may be challenging to achieve a comprehensive and deep understanding of Data Warehouse solely through this article. For your in-depth learning, please take the course, which is an excellent resource, and I personally highly recommend it to those who are eager to master data warehousing, dimensional modeling, and the ETL process.</p>
</blockquote>

<p><img src="/assets/2023-12-19-data-warehouse-06/data-warehouse.webp" alt="" /></p>
<blockquote>
  <p><a href="https://www.udemy.com/course/data-warehouse-the-ultimate-guide/">Source</a></p>
</blockquote>

<h1 id="understanding-the-etl-process">Understanding the ETL Process</h1>

<h3 id="the-layer-of-a-data-warehouse">The Layer of a Data Warehouse</h3>

<p><img src="/assets/2024-01-11-data-warehouse-08/1.png" alt="" /></p>

<p><strong>ETL Setup</strong></p>
<ul>
  <li>1️⃣ Building Workflows
    <ul>
      <li>Staging Workflow</li>
      <li>Core Workflow</li>
      <li>Data Mart Workflow</li>
    </ul>
  </li>
  <li>2️⃣ Jobs
    <ul>
      <li>Run the Workflows</li>
      <li>Scheduled based on Defined Rules</li>
    </ul>
  </li>
</ul>

<h1 id="extracting-data-sources--staging">Extracting (Data Sources → Staging)</h1>

<p><img src="/assets/2024-01-11-data-warehouse-08/2.png" alt="" /></p>

<ul>
  <li>Transient, most commonly.
    <ul>
      <li>All the data is copied and then deleted.</li>
    </ul>
  </li>
  <li>Types of Extracting</li>
</ul>

<table>
  <thead>
    <tr>
      <th><strong>Initial Load</strong></th>
      <th><strong>Delta Load</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>First (real) Run</td>
      <td>Subsequent Runs</td>
    </tr>
    <tr>
      <td>All Data</td>
      <td>Only Additional Data</td>
    </tr>
  </tbody>
</table>

<h1 id="extracting-data-sources--staging-1️⃣-initial-load">Extracting (Data Sources → Staging): 1️⃣ Initial Load</h1>

<ul>
  <li>First Initial Extraction from Source Data</li>
  <li>Followings should be discussed:
    <ul>
      <li>What data is needed?</li>
      <li>When is a good time to load the data? (Night? Weekend?)</li>
      <li>Test with smaller extractions.</li>
      <li>All the transformation steps should have been designed. (up to Core and Data Marts)</li>
    </ul>
  </li>
</ul>

<h1 id="extracting-data-sources--staging-2️⃣-delta-load">Extracting (Data Sources → Staging): 2️⃣ Delta Load</h1>

<ul>
  <li>Incremental Periodic Extraction &amp; Load</li>
  <li><strong>Delta Column</strong>
    <ul>
      <li>Remember <code class="language-plaintext highlighter-rouge">MAX(sales_key)</code></li>
    </ul>
  </li>
</ul>

<pre><code class="language-plain">Variable X = MAX(sales_key)
Next Run: sales_key &gt; X
</code></pre>

<p><img src="/assets/2024-01-11-data-warehouse-08/3.png" alt="" /></p>

<p>What if there is no <strong>Delta Column</strong>?</p>
<ul>
  <li>Some tools can capture automatically which data has already been loaded.</li>
  <li>Just full-load every time and compare the data with data that is already loaded.</li>
  <li>Depending on the data volume → Performance Issue!</li>
</ul>

<h1 id="loading-staging--core-insert--update">Loading (Staging → Core): INSERT &amp; UPDATE</h1>

<p><img src="/assets/2024-01-11-data-warehouse-08/4.png" alt="" /></p>

<ul>
  <li><strong>INSERT or APPEND</strong>
    <ul>
      <li>add new values</li>
    </ul>
  </li>
  <li><strong>UPDATE</strong>
    <ul>
      <li>change the existing values</li>
    </ul>
  </li>
  <li><strong>DELETE</strong>?
    <ul>
      <li>typically, we don’t delete data.</li>
    </ul>
  </li>
</ul>

<h1 id="demo-extracting-data-sources--staging">[DEMO] Extracting (Data Sources → Staging)</h1>

<h3 id="create-table">Create Table</h3>

<p><img src="/assets/2024-01-11-data-warehouse-08/5.png" alt="" /></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">dim_products</code> in Staging Layer</li>
</ul>

<table>
  <thead>
    <tr>
      <th><strong>column</strong></th>
      <th><strong>type</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">product_PK</code></td>
      <td>Surrogate Key</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">product_id</code></td>
      <td>Natural Key</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">product_name</code></td>
      <td> </td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">category</code></td>
      <td> </td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">subcategory</code></td>
      <td> </td>
    </tr>
  </tbody>
</table>

<h3 id="initial-load">Initial Load</h3>

<p><img src="/assets/2024-01-11-data-warehouse-08/6.png" alt="" /></p>

<ul>
  <li>Table input
    <ul>
      <li>from <code class="language-plaintext highlighter-rouge">products</code> in Source</li>
    </ul>
  </li>
  <li>Table output
    <ul>
      <li>to <code class="language-plaintext highlighter-rouge">dim_products</code> in Staging Layer</li>
    </ul>
  </li>
</ul>

<h3 id="delta-load">Delta Load</h3>

<p><img src="/assets/2024-01-11-data-warehouse-08/7.png" alt="" /></p>

<ul>
  <li>Table input
    <ul>
      <li>from <code class="language-plaintext highlighter-rouge">dim_products</code> in Staging Layer</li>
      <li><code class="language-plaintext highlighter-rouge">SELECT MAX(product_id) FROM "Staging".dim_products</code></li>
    </ul>
  </li>
  <li>Set variables
    <ul>
      <li>Save As <code class="language-plaintext highlighter-rouge">LastLoad</code></li>
    </ul>
  </li>
  <li>Get variables
    <ul>
      <li><code class="language-plaintext highlighter-rouge">${LastLoad}</code></li>
    </ul>
  </li>
  <li>Table input
    <ul>
      <li>from <code class="language-plaintext highlighter-rouge">products</code> in Source</li>
      <li><code class="language-plaintext highlighter-rouge">SELECT * FROM "public".products WHERE product_id &gt; ${LastLoad}</code></li>
    </ul>
  </li>
  <li>Table output
    <ul>
      <li>to <code class="language-plaintext highlighter-rouge">dim_products</code> in Staging Layer</li>
    </ul>
  </li>
</ul>

<h1 id="transformations">Transformations</h1>

<h3 id="basic">Basic</h3>

<ul>
  <li>
    <p>Deduplication
<img src="/assets/2024-01-11-data-warehouse-08/8.png" alt="" /></p>
  </li>
  <li>
    <p>Filtering Rows
<img src="/assets/2024-01-11-data-warehouse-08/9.png" alt="" /></p>
  </li>
  <li>
    <p>Filtering Columns
<img src="/assets/2024-01-11-data-warehouse-08/10.png" alt="" /></p>
  </li>
  <li>
    <p>Cleaning &amp; Mapping
<img src="/assets/2024-01-11-data-warehouse-08/11.png" alt="" /></p>
  </li>
  <li>
    <p>Value Standardization
<img src="/assets/2024-01-11-data-warehouse-08/12.png" alt="" /></p>
  </li>
  <li>
    <p>Key Generation
<img src="/assets/2024-01-11-data-warehouse-08/13.png" alt="" /></p>
  </li>
</ul>

<h3 id="advanced">Advanced</h3>

<ul>
  <li>
    <p>Joining
<img src="/assets/2024-01-11-data-warehouse-08/14.png" alt="" /></p>
  </li>
  <li>
    <p>Splitting
<img src="/assets/2024-01-11-data-warehouse-08/15.png" alt="" /></p>
  </li>
  <li>Aggregating
    <ul>
      <li><code class="language-plaintext highlighter-rouge">SUM</code>, <code class="language-plaintext highlighter-rouge">COUNT</code>, <code class="language-plaintext highlighter-rouge">DISTINCT COUNT</code>, <code class="language-plaintext highlighter-rouge">AVERAGE</code>
<img src="/assets/2024-01-11-data-warehouse-08/16.png" alt="" /></li>
    </ul>
  </li>
  <li>Deriving New Values
<img src="/assets/2024-01-11-data-warehouse-08/17.png" alt="" /></li>
</ul>

<h1 id="summary">Summary</h1>

<p><img src="/assets/2024-01-11-data-warehouse-08/18.png" alt="" /></p>

<ul>
  <li><strong>Extract</strong>: Source → Staging
    <ul>
      <li>Add Surrogate Key</li>
      <li>Delta Logic</li>
    </ul>
  </li>
  <li><strong>Transform + Load</strong>: Staging → Core
    <ul>
      <li>Clean Data</li>
      <li>Add Additional Columns</li>
    </ul>
  </li>
</ul>

<h1 id="scheduling">Scheduling</h1>

<h3 id="can-be-done-either">Can be done either:</h3>

<ul>
  <li>directly from the ETL Tool,</li>
  <li>or using External Tool
    <ul>
      <li>e.g., Windows Task Scheduler, Server, etc.</li>
    </ul>
  </li>
</ul>

<h3 id="guidelines">Guidelines</h3>

<ul>
  <li>What are the requirements?
    <ul>
      <li>3 times a day?</li>
      <li>1 time a day?</li>
      <li>Every 30 mins?</li>
    </ul>
  </li>
  <li>How long does it take?
    <ul>
      <li>5 mins?</li>
      <li>1 hour?</li>
    </ul>
  </li>
  <li>What is a good time?
    <ul>
      <li>Initial Load vs. Delta Load</li>
      <li>Effect on the Productive System</li>
      <li>Short Read Access</li>
      <li>Night? Morning?</li>
    </ul>
  </li>
</ul>

<hr />

<h2 id="published-by-joshua-kim"><em>Published by</em> Joshua Kim</h2>
<p><img src="/assets/profile/joshua-profile.png" alt="Joshua Kim" /></p>]]></content><author><name></name></author><category term="SQL" /><category term="Data Warehouse" /><summary type="html"><![CDATA[In this article, I’ll summarize key takeaways from: SECTION 07. Slowly Changing Dimensions]]></summary></entry><entry><title type="html">Data Warehouse #07</title><link href="http://localhost:4000/data-warehouse-07/" rel="alternate" type="text/html" title="Data Warehouse #07" /><published>2024-01-02T00:00:00+09:00</published><updated>2024-01-02T00:00:00+09:00</updated><id>http://localhost:4000/data-warehouse-07</id><content type="html" xml:base="http://localhost:4000/data-warehouse-07/"><![CDATA[<blockquote>
  <p>In this article, I’ll summarize key takeaways from:</p>
  <ul>
    <li>SECTION 07. Slowly Changing Dimensions</li>
  </ul>
</blockquote>

<h3 id="disclaimer">DISCLAIMER</h3>
<blockquote>
  <p>This article is a compilation of key takeaways after completing <a href="https://www.udemy.com/course/data-warehouse-the-ultimate-guide/">Data Warehouse — The Ultimate Guide</a> on Udemy. However, it may be challenging to achieve a comprehensive and deep understanding of Data Warehouse solely through this article. For your in-depth learning, please take the course, which is an excellent resource, and I personally highly recommend it to those who are eager to master data warehousing, dimensional modeling, and the ETL process.</p>
</blockquote>

<p><img src="/assets/2023-12-19-data-warehouse-06/data-warehouse.webp" alt="" /></p>
<blockquote>
  <p><a href="https://www.udemy.com/course/data-warehouse-the-ultimate-guide/">Source</a></p>
</blockquote>

<h1 id="slowly-changing-dimensions">Slowly Changing Dimensions</h1>

<p>Dimensions are rather static than Facts, but they do change in the real world.</p>

<p>Types of Slowly Changing Dimensions (SCDs)</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Type 0</code>: Retain Original</li>
  <li><code class="language-plaintext highlighter-rouge">Type 1</code>: Overwrite</li>
  <li><code class="language-plaintext highlighter-rouge">Type 2</code>: New Row
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Type 2'</code>: Administrative New Row</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">Type 3</code>: Additional Attributes</li>
</ul>

<h1 id="type-0-retain-original">Type 0: Retain Original</h1>
<ul>
  <li>No changes at all.</li>
  <li>Very simple and easy to maintain.</li>
  <li><code class="language-plaintext highlighter-rouge">Dates Table</code> is a great example.</li>
</ul>

<h1 id="type-1-overwrite">Type 1: Overwrite</h1>

<p><img src="/assets/2024-01-02-data-warehouse-07/overwrite.png" alt="" /></p>

<ul>
  <li>Old attributes are just <strong>Overwritten</strong>.</li>
  <li>Only the <strong>Current State</strong> is reflected.</li>
  <li>👍 <strong>Advantages</strong>
    <ul>
      <li>Very simple</li>
      <li>Facts don’t need to be modified.</li>
    </ul>
  </li>
  <li>👎 <strong>Disadvantages</strong>
    <ul>
      <li>History is lost.</li>
      <li>Insignificant Changes ➡️ Do not affect existing queries.
        <ul>
          <li>i.e., product name</li>
        </ul>
      </li>
      <li>Significant Changes ➡️ Affect or break existing queries.
        <ul>
          <li>i.e., category</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h1 id="type-2-new-row">Type 2: New Row</h1>

<p><img src="/assets/2024-01-02-data-warehouse-07/new-row.png" alt="" /></p>

<ul>
  <li>Perfectly partitions <strong>history</strong>.</li>
  <li>Changes are reflected in <strong>history</strong>.</li>
  <li>👎 <strong>Disadvantages</strong>
    <ul>
      <li>Difficult to calculate the total number of products in the current view.</li>
    </ul>
  </li>
</ul>

<h1 id="type-2-administrative-new-row">Type 2’: Administrative New Row</h1>

<p><img src="/assets/2024-01-02-data-warehouse-07/administrative-new-row.png" alt="" /></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">effective_date</code> &amp; <code class="language-plaintext highlighter-rouge">expiration_date</code>
    <ul>
      <li>The period in which values are valid.</li>
      <li><code class="language-plaintext highlighter-rouge">expiration_date</code>
        <ul>
          <li>Avoid <strong>Null</strong> values, and fill in a date far in the future instead.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Requires <strong>Surrogate Key</strong> instead of <strong>Natural Key</strong>.</li>
  <li>Lookup from the Query
    <ul>
      <li>Step 1) Find the Natural Key. (<code class="language-plaintext highlighter-rouge">product_PK</code>)</li>
      <li>Step 2) Then, find the Valid Period. (<code class="language-plaintext highlighter-rouge">effective_date</code> &amp; <code class="language-plaintext highlighter-rouge">expiration_date</code>)</li>
      <li>Step 3) <code class="language-plaintext highlighter-rouge">is_current</code> column is optional.</li>
    </ul>
  </li>
</ul>

<h1 id="type-3-additional-attributes">Type 3: Additional Attributes</h1>

<p><img src="/assets/2024-01-02-data-warehouse-07/additional-attributes.png" alt="" /></p>

<ul>
  <li>Instead of adding a row, we <strong>add a column</strong>.</li>
  <li>Enables to switch between historical &amp; current views.</li>
  <li>It’s typically used for significant changes at a time.
    <ul>
      <li>i.e., Restructuring in an organization</li>
    </ul>
  </li>
  <li>👎 <strong>Disadvantages</strong>
    <ul>
      <li>Minor Changes ➡️ Type 1 is better.</li>
      <li>Frequent or Unpredictable Changes ➡️ Type 2 is better.</li>
    </ul>
  </li>
</ul>

<hr />

<h2 id="published-by-joshua-kim"><em>Published by</em> Joshua Kim</h2>
<p><img src="/assets/profile/joshua-profile.png" alt="Joshua Kim" /></p>]]></content><author><name></name></author><category term="SQL" /><category term="Data Warehouse" /><summary type="html"><![CDATA[In this article, I’ll summarize key takeaways from: SECTION 07. Slowly Changing Dimensions]]></summary></entry><entry><title type="html">데이터 분석가의 SQL 최적화 일기: 코호트 리텐션 Batch Query 만들기</title><link href="http://localhost:4000/retention-batch-query/" rel="alternate" type="text/html" title="데이터 분석가의 SQL 최적화 일기: 코호트 리텐션 Batch Query 만들기" /><published>2024-01-01T00:00:00+09:00</published><updated>2024-01-01T00:00:00+09:00</updated><id>http://localhost:4000/retention-batch-query</id><content type="html" xml:base="http://localhost:4000/retention-batch-query/"><![CDATA[<blockquote>
  <p>코호트 리텐션의 의미와 중요성에 대해 말씀드리고, Batch Query를 사용하여 회원가입 월 코호트 별로 Monthly Range Retention을 계산하는 방법을 제시해드릴게요.</p>
</blockquote>

<h3 id="contents">CONTENTS</h3>
<ol>
  <li>코호트 리텐션의 의미와 중요성
    <ul>
      <li>1.1. 리텐션</li>
      <li>1.2. 코호트</li>
      <li>1.3. 코호트 리텐션</li>
      <li>1.4. 코호트 리텐션의 중요성</li>
    </ul>
  </li>
  <li>쿼리 작업 목표</li>
  <li>일회성 쿼리문
    <ul>
      <li>3.1. 쿼리문 보기</li>
      <li>3.2. 문제점</li>
    </ul>
  </li>
  <li>해결 아이디어</li>
  <li>Batch Query를 통해 접근하기</li>
  <li>결론</li>
</ol>

<hr />

<h3 id="disclaimer">DISCLAIMER</h3>
<p>본 아티클은 필자의 전/현 재직 기업의 데이터 분석 현황과 관련이 없으며, 단지 평소에 문제 의식을 지녔던 점에 대한 해결 방법을 스스로 도출해본 내용입니다. 쿼리문 작성에 다른 외부 레퍼런스를 참고하지 않았으며, 분석 환경에 따라 본 내용이 적합하지 않을 수 있으므로 반드시 비판적 고찰을 해주시면 감사드리겠습니다.</p>

<h1 id="1-코호트-리텐션의-의미와-중요성">1. 코호트 리텐션의 의미와 중요성</h1>

<h3 id="11-리텐션">1.1. 리텐션</h3>

<p>먼저, 리텐션은 “시간이 흐름에 따라 얼마나 많은 사용자들이 우리 프로덕트에 재참여하는지”를 나타내는 지표입니다. 이미 많은 분들이 아시듯 리텐션은 PMF를 달성하기 위해 분석해야 할 중요한 지표입니다. 이 정의가 꽤나 간단해보이지만, 측정하는 과정에서 실상은 그렇지 않습니다. “재참여”를 “재”와 “참여”로 나누어 각각의 사전 정의가 이루어져야 하기 때문입니다.</p>

<p><strong>“참여” 개념 정의하기</strong></p>

<p>사용자가 우리 프로덕트에 “참여”한다는 것이 정확히 어떤 순간인지 정의해야 합니다. 예를 들어, 접속, 30초 이상 세션 유지, 특정 퍼널 단계 도달 등 여러 이벤트 중 하나가 “참여”로 간주될 수 있습니다. 저는 개인적으로 아래 3가지 측면 정의를 모두 사전에 준비하여 Target Metric에 따라 적시적소에 모니터링하는 것이 필요하다고 느꼈습니다.</p>

<p>(1) “접속”을 하는 것만으로 참여한 것으로 간주하자!</p>
<ul>
  <li>DAU, WAU, MAU, Stickiness 등의 지표와 직접적으로 연관된 정의 방법이며, 광고 노출 효과를 극대화하는 경우 유용합니다.</li>
</ul>

<p>(2) “구매”까지 해야 참여한 것으로 간주하자!</p>
<ul>
  <li>재구매율 등의 지표와 직접적으로 연관된 정의 방법이며, Recurring Revenue가 중요한 프로덕트에서 중요합니다.</li>
</ul>

<p>(3) “아하 모먼트”에 도달해야 참여한 것으로 간주하자!</p>
<ul>
  <li><a href="https://www.youtube.com/watch?v=0KgOCKJ1PG4">토스의 이승건 대표님에 따르면</a>, 아하 모먼트란 프로덕트의 핵심 가치의 경험하는 순간을 의미합니다.</li>
  <li>X, Y, Z의 조합으로 이루어진 여러 가지 “X 이벤트를 Y 기간 내에 Z번 수행한다” 중 리텐션이 극명하게 높은(가령, 95%) 항목을 사전에 발견하여, 빠르게 PMF를 달성해야 할 때 유용합니다.</li>
</ul>

<p><strong>“재” 개념 정의하기</strong></p>

<p>사용자가 복귀했다는 것을 어떻게 계산할 것인가에 대한 정의가 필요합니다. <a href="https://product.kyobobook.co.kr/detail/S000001766457">양승화님의 그로스해킹에 따르면</a>, Classic Retention, Range Retention, Rolling Retention 중 프로덕트의 특성에 따라 적절한 방법을 선택할 수 있습니다.</p>

<p>(1) Classic Retention: 사용자가 최초로 “참여”한 Day 0 이후, 각 Day N 별로 한 번 더 “참여”했는지 계산합니다.</p>

<p>(2) Range Retention: Day N이 아니라 Week N, Bi-week N, Month N 별로 한 번 더 “참여”했는지 계산합니다.</p>

<p>(3) Rolling Retention: Day N 이후에 한 번이라도 “참여”한 경우를 계산합니다. (이탈률의 반대 개념)</p>

<p><strong>이러한 정의와 측정 방법을 통해 효과적인 리텐션 지표 측정이 가능해질 것입니다.</strong></p>

<h3 id="12-코호트">1.2. 코호트</h3>

<p>코호트의 개념을 두 가지로 혼용하는 경향이 있습니다.</p>
<ol>
  <li><em>“코호트는 세그먼트다. 즉, 사용자가 지닌 여러 가지 Feature 조합을 통해 그룹화된 클러스터다.”</em></li>
  <li><em>“코호트는 세그먼트의 일부로서, 특정 이벤트의 최초 수행일시를 기준으로 그룹화된 클러스터다.” (최초 프로덕트 방문일, 회원가입일, 최초 결제일 등)</em></li>
</ol>

<p>개인적으로는 세그먼트와의 혼동을 줄이기 위해 2번의 개념을 선호하지만, 코호트를 융통성 있게 설정하기 위해 1번 개념에서 언급한 다른 Feature 조합도 선택적으로 추가할 수 있는 “열린 개념”으로 받아들이고 있습니다.</p>

<ul>
  <li>예시 1) 사용자를 최초 프로덕트 방문일 기준으로 그룹화한다. → 코호트 O</li>
  <li>예시 2) 사용자를 최초 접속 국가 기준으로 그룹화한다. → 코호트 X</li>
  <li>예시 3) 사용자를 최초 프로덕트 방문일 및 접속 국가 기준으로 그룹화한다. → 코호트 O</li>
</ul>

<p>이렇게 하면 특정 이벤트의 최초 수행일시를 중심으로 하면서도 다양한 특성을 고려할 수 있어서 코호트를 보다 유연하게 활용할 수 있을 것입니다.</p>

<h3 id="13-코호트-리텐션">1.3. 코호트 리텐션</h3>

<p>코호트 리텐션이란, 기존의 리텐션 개념을 코호트에 따라 시리즈를 달리하여 계산한 지표를 의미합니다. 예를 들면, 최초 프로덕트 방문일을 기준으로 사용자들의 리텐션이 상승 추세인지, 혹은 하락 추세인지를 알 수 있는 것이죠.</p>

<h3 id="14-코호트-리텐션의-중요성">1.4. 코호트 리텐션의 중요성</h3>

<p>아래의 리텐션 지표를 통해 PMF 달성 여부를 확인할 수 있지만, 문제를 파악하거나 액션 포인트를 도출하는 데는 그다지 도움이 되지 않습니다.</p>

<p><img src="/assets/2024-01-01-retention-batch-query/retention.webp" alt="" /></p>
<blockquote>
  <p><a href="https://mermaid.js.org/syntax/xyChart.html">mermaid</a>를 통해 필자가 직접 작성</p>
</blockquote>

<p>그러나 코호트 리텐션 값을 확인할 수 있다면, 프로덕트의 기능 업데이트나 캠페인 론칭 등에 따른 사후 효과를 확인하고, 리텐션 향상을 위해 우리가 어떤 액션에 좀 더 집중해야 하는지 확인하는 데 도움을 줄 수 있습니다.</p>

<p><img src="/assets/2024-01-01-retention-batch-query/cohort-retention.webp" alt="" /></p>
<blockquote>
  <p><a href="https://mermaid.js.org/syntax/xyChart.html">mermaid</a>를 통해 필자가 직접 작성</p>
</blockquote>

<h1 id="2-쿼리-작업-목표">2. 쿼리 작업 목표</h1>

<p>쿼리 작업 목표는 다음과 같습니다. 아래와 같은 테이블을 대시보드에 반영해보고자 합니다. 즉, 회원가입 연월(YYYY-MM) 코호트별 리텐션(Monthly Range)테이블을 배포하여 다양한 이해당사자 분들이 리텐션 지표의 시계열 추이를 확인하시는 데 도움을 드리려는 것입니다.</p>

<p><img src="/assets/2024-01-01-retention-batch-query/task-goal.webp" alt="" /></p>
<blockquote>
  <p>제가 직접 샘플로 만들어본 위 테이블에서는 시간이 흐를수록 리텐션이 향상되는 추이를 보여주고 있군요.</p>
</blockquote>

<p>그런데, 위와 같은 테이블을 만들기 위해서는 SQL의 최후 출력 상태가 다음과 같은 Unpivoted한 형태가 되어야 합니다. 물론 Pivoted한 형태로 직접 출력하는 방법도 있지만, 오늘의 토픽인 “Batch Query 만들기”를 위해서는 Unpivoted한 형태가 되어야 합니다. Table을 Update를 방지하고, 오로지 Insert 작업만 수행함으로써 연산 부하를 방지하기 위함인데요. 지금부터 차차 읽어가시면 이해가 되실 겁니다.</p>

<p><img src="/assets/2024-01-01-retention-batch-query/last-query-results.webp" alt="" /></p>
<blockquote>
  <p>필자가 직접 작성</p>
</blockquote>

<h1 id="3-일회성-쿼리문">3. 일회성 쿼리문</h1>

<h3 id="31-쿼리문-보기">3.1. 쿼리문 보기</h3>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">WITH</span>

<span class="c1">-- 1. 사용자들의 "참여" (회원가입 및 로그인 이벤트) 소스 테이블을 불러온다.</span>
<span class="n">CTE_engagements</span> <span class="k">AS</span> <span class="p">(</span>
    <span class="k">SELECT</span>
        <span class="n">user_id</span><span class="p">,</span>
        <span class="n">DATE_TRUNC</span><span class="p">(</span><span class="s1">'DAY'</span><span class="p">,</span> <span class="nb">datetime</span><span class="p">)</span> <span class="k">AS</span> <span class="nb">date</span>
    <span class="k">FROM</span>
        <span class="n">signups_logins</span>
    <span class="k">GROUP</span> <span class="k">BY</span>
        <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span>
<span class="p">),</span>

<span class="c1">-- 2. 사용자들을 회원가입일 기준의 코호트로 Labeling해준다.</span>
<span class="n">CTE_cohorts</span> <span class="k">AS</span> <span class="p">(</span>
    <span class="k">SELECT</span>
        <span class="n">user_id</span><span class="p">,</span>
        <span class="k">MIN</span><span class="p">(</span><span class="nb">date</span><span class="p">)</span> <span class="k">AS</span> <span class="n">cohort_date</span>
    <span class="k">FROM</span>
        <span class="n">CTE_engagements</span>
    <span class="k">GROUP</span> <span class="k">BY</span>
        <span class="mi">1</span>
<span class="p">),</span>

<span class="c1">-- 3. 사용자들의 "참여" 테이블과 "코호트 Labeling" 테이블을 조인하여 "Day N"도 함께 표시해준다.</span>
<span class="n">CTE_engagements_with_cohorts_daily</span> <span class="k">AS</span> <span class="p">(</span>
    <span class="k">SELECT</span>
        <span class="n">ENG</span><span class="p">.</span><span class="n">user_id</span><span class="p">,</span>
        <span class="n">ENG</span><span class="p">.</span><span class="nb">date</span><span class="p">,</span>
        <span class="n">COH</span><span class="p">.</span><span class="n">cohort_date</span><span class="p">,</span>
        <span class="n">DATE_DIFF</span><span class="p">(</span>
            <span class="n">ENG</span><span class="p">.</span><span class="nb">date</span><span class="p">,</span>
            <span class="n">COH</span><span class="p">.</span><span class="n">cohort_date</span><span class="p">,</span>
            <span class="k">DAY</span>
        <span class="p">)</span> <span class="k">AS</span> <span class="n">day_n</span>
    <span class="k">FROM</span>
        <span class="n">CTE_engagements</span> <span class="n">ENG</span>
    <span class="k">LEFT</span> <span class="k">JOIN</span>
        <span class="n">CTE_cohorts</span> <span class="n">COH</span>
        <span class="k">USING</span> <span class="p">(</span><span class="n">user_id</span><span class="p">)</span>
<span class="p">),</span>

<span class="c1">-- 4. "Day N"을 "Month N"으로 변환해준다.</span>
<span class="n">CTE_engagements_with_cohorts_monthly</span> <span class="k">AS</span> <span class="p">(</span>
    <span class="k">SELECT</span>
        <span class="n">user_id</span><span class="p">,</span>
        <span class="n">DATE_TRUNC</span><span class="p">(</span><span class="s1">'MONTH'</span><span class="p">,</span> <span class="nb">date</span><span class="p">)</span> <span class="k">AS</span> <span class="n">yyyymm</span><span class="p">,</span>
        <span class="n">DATE_TRUNC</span><span class="p">(</span><span class="s1">'MONTH'</span><span class="p">,</span> <span class="n">cohort_date</span><span class="p">)</span> <span class="k">AS</span> <span class="n">cohort_yyyymm</span><span class="p">,</span>
        <span class="n">DATE_DIFF</span><span class="p">(</span>
            <span class="nb">date</span><span class="p">,</span>
            <span class="n">cohort_date</span><span class="p">,</span>
            <span class="k">MONTH</span>
        <span class="p">)</span> <span class="k">AS</span> <span class="n">month_n</span>
    <span class="k">FROM</span>
        <span class="n">CTE_engagements_with_cohorts_daily</span>
<span class="p">),</span>

<span class="c1">-- 5. 코호트 및 "Month N" 기준으로 사용자 수를 집계한다.</span>
<span class="n">CTE_month_n_cnt</span> <span class="k">AS</span> <span class="p">(</span>
    <span class="k">SELECT</span>
        <span class="n">cohort_yyyymm</span><span class="p">,</span>
        <span class="n">month_n</span><span class="p">,</span>
        <span class="k">COUNT</span><span class="p">(</span><span class="k">DISTINCT</span> <span class="n">user_id</span><span class="p">)</span> <span class="k">AS</span> <span class="n">users_cnt</span>
    <span class="k">FROM</span>
        <span class="n">CTE_engagements_with_cohorts_monthly</span>
    <span class="k">GROUP</span> <span class="k">BY</span>
        <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span>
<span class="p">),</span>

<span class="c1">-- 6. 최종 리텐션을 계산한다.</span>
<span class="n">CTE_monthly_retention</span> <span class="k">AS</span> <span class="p">(</span>
    <span class="k">SELECT</span>
        <span class="n">cohort_yyyymm</span><span class="p">,</span>
        <span class="n">month_n</span><span class="p">,</span>
        <span class="k">CAST</span><span class="p">(</span><span class="n">users_cnt</span> <span class="k">AS</span> <span class="nb">DOUBLE</span><span class="p">)</span>
        <span class="o">/</span>
        <span class="k">CAST</span><span class="p">(</span><span class="n">FIRST_VALUE</span><span class="p">(</span><span class="n">users_cnt</span><span class="p">)</span> <span class="n">OVER</span> <span class="p">(</span>
            <span class="k">PARTITION</span> <span class="k">BY</span> <span class="n">cohort_yyyymm</span>
            <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">month_n</span>
            <span class="k">ROWS</span> <span class="k">BETWEEN</span> <span class="n">UNBOUNDED</span> <span class="k">PRECEDING</span> <span class="k">AND</span> <span class="n">UNBOUNDED</span> <span class="k">FOLLOWING</span>
            <span class="p">)</span> <span class="k">AS</span> <span class="nb">DOUBLE</span>
        <span class="p">)</span> <span class="k">AS</span> <span class="n">monthly_retention</span>
    <span class="k">FROM</span>
        <span class="n">CTE_month_n_cnt</span>
    <span class="k">ORDER</span> <span class="k">BY</span>
        <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span>
<span class="p">)</span>
<span class="k">SELECT</span>
    <span class="o">*</span>
<span class="k">FROM</span>
    <span class="n">CTE_monthly_retention</span>
<span class="p">;</span>
</code></pre></div></div>

<h3 id="32-문제점">3.2. 문제점</h3>

<p>위 쿼리문의 출력 결과는 앞서 잠깐 보여드린 아래와 같은 형태의 테이블을 출력합니다. 그런데, 매번 전체 소스 테이블을 메모리에 올려 리텐션을 계산하려면 연산량이 과도하게 많이 들어 리소스 낭비로 이어지게 됩니다.</p>

<p><img src="/assets/2024-01-01-retention-batch-query/last-query-results.webp" alt="" /></p>
<blockquote>
  <p>필자가 직접 작성</p>
</blockquote>

<h1 id="4-해결-아이디어">4. 해결 아이디어</h1>

<p>마침, Cohort 칼럼과 Month 칼럼이 시계열 형식을 지니고 있으므로 미래의 데이터가 과거의 데이터에 영향을 끼칠 수 없습니다. 또한, 출력된 테이블은  <a href="https://www.kimballgroup.com/data-warehouse-business-intelligence-resources/kimball-techniques/dimensional-modeling-techniques/periodic-snapshot-fact-table/">Periodic Snapshot Fact Table</a>의 유형에 해당합니다. 바로 이 점으로부터 우리는 Batch Query를 활용할 수 있는 여지를 발견할 수 있습니다. 즉, 아래와 같이 매월 1일 00:01 UTC마다 새롭게 획득한 리텐션 값들을 Insert할 수 있는 Batch Query를 작성할 수 있는 것입니다. 특히 이벤트 로그 데이터의 크기가 매우 큰 프로덕트를 운영하고 있다면, 굳이 매번 일회성 쿼리문을 실행할 필요가 없는 셈이죠.</p>

<p><img src="/assets/2024-01-01-retention-batch-query/idea.webp" alt="" /></p>
<blockquote>
  <p>즉, 매월 초마다 좌측 테이블의 빨간색 영역들을 순차적으로 신규 계산하여 테이블 Insert 스케줄링을 구현할 수 있는 것이죠. (필자가 직접 작성)</p>
</blockquote>

<h1 id="5-batch-query를-통해-접근하기">5. Batch Query를 통해 접근하기</h1>

<p><strong>STEP 1) 사용자들의 “참여” 소스 테이블을 불러온다. (단, 현재 시점 기준으로 7개월 전의 월초부터 1개월 전의 월말까지 항목만)</strong></p>

<p><img src="/assets/2024-01-01-retention-batch-query/step1.webp" alt="" /></p>
<blockquote>
  <p>필자가 직접 작성</p>
</blockquote>

<ul>
  <li>로그인했을 때 사용자가 “참여”했다고 가정 하에, 로그인 이벤트를 불러온다.</li>
  <li>코호트는 “회원가입” 기준으로 정의할 것이므로, 회원가입 이벤트도 함께 불러온다.</li>
  <li>Monthly Range Retention은 Month 0부터 Month 6까지만 계산한다.</li>
</ul>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">WITH</span>  
  
<span class="c1">-- 1. 사용자들의 "참여" (회원가입 및 로그인 이벤트) 소스 테이블을 불러온다.  </span>
<span class="c1">-- (단, 현재 시점 기준으로 7개월 전의 월초부터 1개월 전의 월말까지 항목만)  </span>
<span class="n">CTE_engagements</span> <span class="k">AS</span> <span class="p">(</span>  
    <span class="k">SELECT</span>  
        <span class="n">user_id</span><span class="p">,</span>  
        <span class="n">DATE_TRUNC</span><span class="p">(</span><span class="s1">'DAY'</span><span class="p">,</span> <span class="nb">datetime</span><span class="p">)</span> <span class="k">AS</span>  <span class="nb">date</span>  
    <span class="k">FROM</span>
        <span class="k">source</span><span class="p">.</span><span class="n">signups_logins</span>
    <span class="nv">"if is_incremental()"</span>
    <span class="k">WHERE</span>  
        <span class="c1">-- 현재 시점 기준으로 7개월 전의 월초부터 ~  </span>
        <span class="n">DATE_TRUNC</span><span class="p">(</span><span class="s1">'MONTH'</span><span class="p">,</span> <span class="k">CURRENT_DATE</span><span class="p">)</span> <span class="o">-</span> <span class="n">INTERVAL</span> <span class="s1">'7'</span> <span class="k">MONTH</span>  
        <span class="o">&lt;=</span> <span class="n">DATE_TRUNC</span><span class="p">(</span><span class="s1">'DAY'</span><span class="p">,</span> <span class="nb">datetime</span><span class="p">)</span>  
        <span class="c1">-- ~ 현재 시점 기준으로 1개월 전의 월말까지  </span>
        <span class="k">AND</span> <span class="n">DATE_TRUNC</span><span class="p">(</span><span class="s1">'DAY'</span><span class="p">,</span> <span class="nb">datetime</span><span class="p">)</span>  
        <span class="o">&lt;=</span> <span class="n">DATE_TRUNC</span><span class="p">(</span><span class="s1">'MONTH'</span><span class="p">,</span> <span class="k">CURRENT_DATE</span><span class="p">)</span> <span class="o">-</span> <span class="n">INTERVAL</span> <span class="s1">'1'</span> <span class="k">DAY</span>  
    <span class="nv">"endif"</span>
    <span class="k">GROUP</span> <span class="k">BY</span>  
        <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span>  
<span class="p">),</span>
</code></pre></div></div>

<p><strong>STEP 2) 사용자들을 회원가입일 기준의 코호트로 Labeling해준다.</strong></p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- 2. 사용자들을 회원가입일 기준의 코호트로 Labeling해준다.  </span>
<span class="n">CTE_cohorts</span> <span class="k">AS</span> <span class="p">(</span>  
    <span class="k">SELECT</span>  
        <span class="n">user_id</span><span class="p">,</span>  
        <span class="k">MIN</span><span class="p">(</span><span class="nb">date</span><span class="p">)</span> <span class="k">AS</span> <span class="n">cohort_date</span>  
    <span class="k">FROM</span>  
        <span class="n">CTE_engagements</span>  
    <span class="k">GROUP</span> <span class="k">BY</span>  
        <span class="mi">1</span>  
<span class="p">),</span>
</code></pre></div></div>

<p><strong>STEP 3) 사용자들의 “참여” 테이블과 “코호트 Labeling” 테이블을 조인하여 “Day N”도 함께 표시해준다.</strong></p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- 3. 사용자들의 "참여" 테이블과 "코호트 Labeling" 테이블을 조인하여 "Day N"도 함께 표시해준다.  </span>
<span class="n">CTE_engagements_with_cohorts_daily</span> <span class="k">AS</span> <span class="p">(</span>  
    <span class="k">SELECT</span>  
        <span class="n">ENG</span><span class="p">.</span><span class="n">user_id</span><span class="p">,</span>  
        <span class="n">ENG</span><span class="p">.</span><span class="nb">date</span><span class="p">,</span>  
        <span class="n">COH</span><span class="p">.</span><span class="n">cohort_date</span><span class="p">,</span>  
        <span class="n">DATE_DIFF</span><span class="p">(</span>  
            <span class="n">ENG</span><span class="p">.</span><span class="nb">date</span><span class="p">,</span>  
            <span class="n">COH</span><span class="p">.</span><span class="n">cohort_date</span><span class="p">,</span>  
            <span class="k">DAY</span>  
        <span class="p">)</span> <span class="k">AS</span> <span class="n">day_n</span>  
    <span class="k">FROM</span>  
        <span class="n">CTE_engagements</span> <span class="n">ENG</span>  
    <span class="k">LEFT</span> <span class="k">JOIN</span>  
        <span class="n">CTE_cohorts</span> <span class="n">COH</span>  
        <span class="k">USING</span> <span class="p">(</span><span class="n">user_id</span><span class="p">)</span>  
<span class="p">),</span>
</code></pre></div></div>

<p><strong>STEP 4) “Day N”을 “Month N”으로 변환해준다.</strong></p>
<ul>
  <li>Monthly Range Retention을 계산해야 하기 때문이다.</li>
</ul>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- 4. "Day N"을 "Month N"으로 변환해준다.  </span>
<span class="n">CTE_engagements_with_cohorts_monthly</span> <span class="k">AS</span> <span class="p">(</span>  
    <span class="k">SELECT</span>  
        <span class="n">user_id</span><span class="p">,</span>  
        <span class="n">DATE_TRUNC</span><span class="p">(</span><span class="s1">'MONTH'</span><span class="p">,</span> <span class="nb">date</span><span class="p">)</span> <span class="k">AS</span> <span class="n">yyyymm</span><span class="p">,</span>  
        <span class="n">DATE_TRUNC</span><span class="p">(</span><span class="s1">'MONTH'</span><span class="p">,</span> <span class="n">cohort_date</span><span class="p">)</span> <span class="k">AS</span> <span class="n">cohort_yyyymm</span><span class="p">,</span>  
        <span class="n">DATE_DIFF</span><span class="p">(</span>  
            <span class="nb">date</span><span class="p">,</span>  
            <span class="n">cohort_date</span><span class="p">,</span>  
            <span class="k">MONTH</span>  
        <span class="p">)</span> <span class="k">AS</span> <span class="n">month_n</span>  
    <span class="k">FROM</span>  
        <span class="n">CTE_engagements_with_cohorts_daily</span>  
<span class="p">),</span>
</code></pre></div></div>

<p><strong>STEP 5) 코호트 및 “Month N” 기준으로 사용자 수를 집계한다.</strong></p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- 5. 코호트 및 "Month N" 기준으로 사용자 수를 집계한다.  </span>
<span class="n">CTE_month_n_cnt</span> <span class="k">AS</span> <span class="p">(</span>  
    <span class="k">SELECT</span>  
        <span class="n">cohort_yyyymm</span><span class="p">,</span>  
        <span class="n">month_n</span><span class="p">,</span>  
        <span class="k">COUNT</span><span class="p">(</span><span class="k">DISTINCT</span> <span class="n">user_id</span><span class="p">)</span> <span class="k">AS</span> <span class="n">users_cnt</span>  
    <span class="k">FROM</span>  
        <span class="n">CTE_engagements_with_cohorts_monthly</span>  
    <span class="k">GROUP</span> <span class="k">BY</span>  
        <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span>  
<span class="p">),</span>
</code></pre></div></div>

<p><strong>STEP 6) 최종 리텐션을 계산한다.</strong></p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- 6. 최종 리텐션을 계산한다.  </span>
<span class="n">CTE_monthly_retention</span> <span class="k">AS</span> <span class="p">(</span>  
    <span class="k">SELECT</span>  
        <span class="n">cohort_yyyymm</span><span class="p">,</span>  
        <span class="n">month_n</span><span class="p">,</span>  
        <span class="k">CAST</span><span class="p">(</span><span class="n">users_cnt</span> <span class="k">AS</span> <span class="nb">DOUBLE</span><span class="p">)</span>  
        <span class="o">/</span>  
        <span class="k">CAST</span><span class="p">(</span><span class="n">FIRST_VALUE</span><span class="p">(</span><span class="n">users_cnt</span><span class="p">)</span> <span class="n">OVER</span> <span class="p">(</span>  
            <span class="k">PARTITION</span> <span class="k">BY</span> <span class="n">cohort_yyyymm</span>  
            <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">month_n</span>  
            <span class="k">ROWS</span> <span class="k">BETWEEN</span> <span class="n">UNBOUNDED</span> <span class="k">PRECEDING</span> <span class="k">AND</span> <span class="n">UNBOUNDED</span> <span class="k">FOLLOWING</span>  
        <span class="p">)</span>  
        <span class="k">AS</span> <span class="n">monthly_retention</span>  
    <span class="k">FROM</span>  
        <span class="n">CTE_month_n_cnt</span>  
    <span class="k">ORDER</span> <span class="k">BY</span>  
        <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span>  
<span class="p">)</span>
</code></pre></div></div>

<p><strong>STEP 7) 중복되지 않은 신규 항목들만 Insert할 수 있도록 조건화한다.</strong></p>

<p><img src="/assets/2024-01-01-retention-batch-query/step7.webp" alt="" /></p>
<blockquote>
  <p>필자가 직접 작성</p>
</blockquote>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- 7. 중복되지 않은 신규 항목들만 Insert할 수 있도록 조건화한다.  </span>
<span class="n">CTE_monthly_retention_inserted</span> <span class="k">AS</span> <span class="p">(</span>  
    <span class="k">SELECT</span>  
        <span class="o">*</span>  
    <span class="k">FROM</span>  
        <span class="n">CTE_monthly_retention</span>  
    <span class="nv">"if is_incremental()"</span>
    <span class="k">WHERE</span>  
        <span class="c1">-- 현재 시점 기준으로 1개월 전의 코호트: Month 0 리텐션 값만 Insert한다.  </span>
        <span class="p">(</span><span class="n">cohort_yyyymm</span> <span class="o">=</span> <span class="n">DATE_TRUNC</span><span class="p">(</span><span class="s1">'MONTH'</span><span class="p">,</span> <span class="k">CURRENT_DATE</span><span class="p">)</span> <span class="o">-</span> <span class="n">INTERVAL</span> <span class="s1">'1'</span> <span class="k">MONTH</span> <span class="k">AND</span> <span class="n">month_n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>  
        <span class="c1">-- 현재 시점 기준으로 2개월 전의 코호트: Month 1 리텐션 값만 Insert한다.  </span>
        <span class="k">OR</span> <span class="p">(</span><span class="n">cohort_yyyymm</span> <span class="o">=</span> <span class="n">DATE_TRUNC</span><span class="p">(</span><span class="s1">'MONTH'</span><span class="p">,</span> <span class="k">CURRENT_DATE</span><span class="p">)</span> <span class="o">-</span> <span class="n">INTERVAL</span> <span class="s1">'2'</span> <span class="k">MONTH</span> <span class="k">AND</span> <span class="n">month_n</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>  
        <span class="c1">-- 현재 시점 기준으로 3개월 전의 코호트: Month 2 리텐션 값만 Insert한다.  </span>
        <span class="k">OR</span> <span class="p">(</span><span class="n">cohort_yyyymm</span> <span class="o">=</span> <span class="n">DATE_TRUNC</span><span class="p">(</span><span class="s1">'MONTH'</span><span class="p">,</span> <span class="k">CURRENT_DATE</span><span class="p">)</span> <span class="o">-</span> <span class="n">INTERVAL</span> <span class="s1">'3'</span> <span class="k">MONTH</span> <span class="k">AND</span> <span class="n">month_n</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span>  
        <span class="c1">-- 현재 시점 기준으로 4개월 전의 코호트: Month 3 리텐션 값만 Insert한다.  </span>
        <span class="k">OR</span> <span class="p">(</span><span class="n">cohort_yyyymm</span> <span class="o">=</span> <span class="n">DATE_TRUNC</span><span class="p">(</span><span class="s1">'MONTH'</span><span class="p">,</span> <span class="k">CURRENT_DATE</span><span class="p">)</span> <span class="o">-</span> <span class="n">INTERVAL</span> <span class="s1">'4'</span> <span class="k">MONTH</span> <span class="k">AND</span> <span class="n">month_n</span> <span class="o">=</span> <span class="mi">3</span><span class="p">)</span>  
        <span class="c1">-- 현재 시점 기준으로 5개월 전의 코호트: Month 4 리텐션 값만 Insert한다.  </span>
        <span class="k">OR</span> <span class="p">(</span><span class="n">cohort_yyyymm</span> <span class="o">=</span> <span class="n">DATE_TRUNC</span><span class="p">(</span><span class="s1">'MONTH'</span><span class="p">,</span> <span class="k">CURRENT_DATE</span><span class="p">)</span> <span class="o">-</span> <span class="n">INTERVAL</span> <span class="s1">'5'</span> <span class="k">MONTH</span> <span class="k">AND</span> <span class="n">month_n</span> <span class="o">=</span> <span class="mi">4</span><span class="p">)</span>  
        <span class="c1">-- 현재 시점 기준으로 6개월 전의 코호트: Month 5 리텐션 값만 Insert한다.  </span>
        <span class="k">OR</span> <span class="p">(</span><span class="n">cohort_yyyymm</span> <span class="o">=</span> <span class="n">DATE_TRUNC</span><span class="p">(</span><span class="s1">'MONTH'</span><span class="p">,</span> <span class="k">CURRENT_DATE</span><span class="p">)</span> <span class="o">-</span> <span class="n">INTERVAL</span> <span class="s1">'6'</span> <span class="k">MONTH</span> <span class="k">AND</span> <span class="n">month_n</span> <span class="o">=</span> <span class="mi">5</span><span class="p">)</span>  
        <span class="c1">-- 현재 시점 기준으로 7개월 전의 코호트: Month 6 리텐션 값만 Insert한다.  </span>
        <span class="k">OR</span> <span class="p">(</span><span class="n">cohort_yyyymm</span> <span class="o">=</span> <span class="n">DATE_TRUNC</span><span class="p">(</span><span class="s1">'MONTH'</span><span class="p">,</span> <span class="k">CURRENT_DATE</span><span class="p">)</span> <span class="o">-</span> <span class="n">INTERVAL</span> <span class="s1">'7'</span> <span class="k">MONTH</span> <span class="k">AND</span> <span class="n">month_n</span> <span class="o">=</span> <span class="mi">6</span><span class="p">)</span>  
    <span class="nv">"endif"</span>
    <span class="k">ORDER</span> <span class="k">BY</span>  
        <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span>  
<span class="p">)</span>
</code></pre></div></div>

<p><strong>STEP 8) 출력한다.</strong></p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span>  
    <span class="o">*</span>  
<span class="k">FROM</span>  
    <span class="n">CTE_monthly_retention_inserted</span>  
<span class="p">;</span>
</code></pre></div></div>

<h1 id="6-결론">6. 결론</h1>

<p>Data Mart나 Batch Query에 대한 이론은 누구나 쉽게 온라인에서 공부할 수 있지만, 실제 Metrics 별로 모범이 될 만한 레퍼런스를 찾기가 어려운 것 같습니다. 특히, 리텐션의 경우 분명히 일회성 쿼리의 문제점을 해결해야 할 필요성이 클 것임에도 불구하고 저는 개인적으로 구글링을 통해서 적절한 레퍼런스를 전혀 찾지 못했습니다. 그래서 이참에 퍼블릭 레퍼런스를 제가 한 번 만들어보자는 결심이 들어 이렇게 글을 적어봤습니다.</p>

<p>그러나 저의 레퍼런스가 절대로 정답은 아닐 것입니다. Batch Query 모범 사례를 찾기 어렵다는 점은 그만큼 각 프로덕트의 도메인 특수성과 데이터의 형태가 극명하게 달라 절대불변의 정답이 없다는 의미일지도 모르겠습니다.</p>

<p>그러므로, 저의 사례는 가볍게 참고만 해주시고, 독자 분들께서 처한 다양한 특수성에 따라 가장 효율적인 리텐션 측정 환경을 구축하시길 바라겠습니다. 물론, 저의 논리적 오류나 개선 방향에 대한 피드백도 언제나 감사히 받겠습니다. 읽어주셔서 감사합니다.</p>

<hr />

<h2 id="published-by-joshua-kim"><em>Published by</em> Joshua Kim</h2>
<p><img src="/assets/profile/joshua-profile.png" alt="Joshua Kim" /></p>]]></content><author><name></name></author><category term="Data Analysis" /><category term="SQL" /><category term="Data Warehouse" /><summary type="html"><![CDATA[코호트 리텐션의 의미와 중요성에 대해 말씀드리고, Batch Query를 사용하여 회원가입 월 코호트 별로 Monthly Range Retention을 계산하는 방법을 제시해드릴게요.]]></summary></entry><entry><title type="html">Data Warehouse #06</title><link href="http://localhost:4000/data-warehouse-06/" rel="alternate" type="text/html" title="Data Warehouse #06" /><published>2023-12-19T00:00:00+09:00</published><updated>2023-12-19T00:00:00+09:00</updated><id>http://localhost:4000/data-warehouse-06</id><content type="html" xml:base="http://localhost:4000/data-warehouse-06/"><![CDATA[<blockquote>
  <p>In this article, I’ll summarize key takeaways from:</p>
  <ul>
    <li>SECTION 06. Dimensions</li>
  </ul>
</blockquote>

<h3 id="disclaimer">DISCLAIMER</h3>
<blockquote>
  <p>This article is a compilation of key takeaways after completing <a href="https://www.udemy.com/course/data-warehouse-the-ultimate-guide/">Data Warehouse — The Ultimate Guide</a> on Udemy. However, it may be challenging to achieve a comprehensive and deep understanding of Data Warehouse solely through this article. For your in-depth learning, please take the course, which is an excellent resource, and I personally highly recommend it to those who are eager to master data warehousing, dimensional modeling, and the ETL process.</p>
</blockquote>

<p><img src="/assets/2023-12-19-data-warehouse-06/data-warehouse.webp" alt="" /></p>
<blockquote>
  <p><a href="https://www.udemy.com/course/data-warehouse-the-ultimate-guide/">Source</a></p>
</blockquote>

<h1 id="dimension-tables">Dimension Tables</h1>

<ul>
  <li>A role of “<strong>group &amp; filter</strong>”</li>
  <li>Always has a <strong>PK(Primary Key)</strong>.
    <ul>
      <li>Recommended to iuse a <strong>Surrogate Key</strong>!
        <ul>
          <li>because a Natural Key may or may not have null values.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Number of Rows &amp; Columns (compared to Fact Tables)
    <ul>
      <li>Number of Rows ⬇️</li>
      <li>Number of Columns ⬆️ (with descriptive attributes)</li>
    </ul>
  </li>
</ul>

<p><img src="/assets/2023-12-19-data-warehouse-06/dimension-tables.png" alt="" /></p>

<h1 id="date-dimensions">Date Dimensions</h1>

<ul>
  <li>One of the most common &amp; important dimensions</li>
  <li>Contains date-related features
    <pre><code class="language-plain">Year, Quarter, Month(Name &amp; Number), Week, Day, Weekday(Name &amp; Number), etc.
Combination: Year-quarter, Year-Month, etc.
</code></pre>
  </li>
  <li>Surrogate Key: <strong><code class="language-plaintext highlighter-rouge">YYYYMMDD</code></strong> (Integer Type)
    <ul>
      <li>The recommended way to fill null values: <code class="language-plaintext highlighter-rouge">NULL</code> dates in Source → <code class="language-plaintext highlighter-rouge">19000101</code> in Dimensions</li>
    </ul>
  </li>
</ul>

<p><img src="/assets/2023-12-19-data-warehouse-06/date-dimensions.png" alt="" /></p>

<ul>
  <li>Date Dimensions can be populated in advance. (for the next 5 or 10 years, for example.)</li>
  <li>Don’t combine time with date!
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Time</code> should be a separate dimension from <code class="language-plaintext highlighter-rouge">Date</code>.</li>
    </ul>
  </li>
  <li>Date Feature Examples</li>
</ul>

<table>
  <thead>
    <tr>
      <th><strong>Type</strong></th>
      <th><strong>Examples</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Number &amp; Text</td>
      <td>January / 1</td>
    </tr>
    <tr>
      <td>Long &amp; Abbreviated</td>
      <td>January / Jan / Monday / Mon</td>
    </tr>
    <tr>
      <td>Combinations of Features</td>
      <td>Q1 / 2022-Q1</td>
    </tr>
    <tr>
      <td>Fiscal Dates</td>
      <td>Fiscal Year, etc.</td>
    </tr>
    <tr>
      <td>Flags</td>
      <td>Weekend, Holiday, etc.</td>
    </tr>
  </tbody>
</table>

<h1 id="nulls-in-dimensions">Nulls in Dimensions</h1>

<h3 id="promotion_fk"><code class="language-plaintext highlighter-rouge">promotion_FK</code></h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">NULL</code> values must be avoided so that they can <strong>appear in JOINs</strong>!</li>
</ul>

<p><img src="/assets/2023-12-19-data-warehouse-06/nulls-in-dimensions-1.png" alt="" /></p>

<h3 id="replace-nulls-with-descriptive-values">Replace Nulls with descriptive values!</h3>
<ul>
  <li>More understandable for business users</li>
  <li>Values appear in aggregations in BI tools</li>
</ul>

<p><img src="/assets/2023-12-19-data-warehouse-06/nulls-in-dimensions-2.png" alt="" /></p>

<h1 id="hierarchies-in-dimensions">Hierarchies in Dimensions</h1>

<h3 id="snowflake-schema">Snowflake Schema</h3>
<ul>
  <li>Should be avoided in Data Mart
    <ul>
      <li>👍 Good for “<strong>Normalization</strong>”</li>
      <li>👎 Bad for “<strong>Query Performance (Read)</strong>”</li>
    </ul>
  </li>
</ul>

<p><img src="/assets/2023-12-19-data-warehouse-06/hierarchies-in-dimensions-1.png" alt="" /></p>

<h3 id="star-schema">Star Schema</h3>
<ul>
  <li><strong>Denormalized</strong> &amp; <strong>Flattened</strong></li>
</ul>

<p><img src="/assets/2023-12-19-data-warehouse-06/hierarchies-in-dimensions-2.png" alt="" /></p>

<h3 id="consider-combinations-if-helpful">Consider combinations if helpful!</h3>

<p><img src="/assets/2023-12-19-data-warehouse-06/hierarchies-in-dimensions-3.png" alt="" /></p>

<h1 id="conformed-dimensions">Conformed Dimensions</h1>

<p><strong>A Confirmed Dimension is a dimension shared by multiple fact tables or stars.</strong></p>
<ul>
  <li>Used to compare facts across different fact tables.</li>
</ul>

<p><img src="/assets/2023-12-19-data-warehouse-06/conformed-dimensions-1.png" alt="" /></p>

<p><img src="/assets/2023-12-19-data-warehouse-06/conformed-dimensions-2.png" alt="" /></p>

<p><strong>The same granularity is not necessary, and a different scope of FK can be possible!</strong></p>

<p><img src="/assets/2023-12-19-data-warehouse-06/conformed-dimensions-3.png" alt="" /></p>

<h1 id="degenerate-dimensions">Degenerate Dimensions</h1>

<p><strong>A Degenerate Dimension is a dimension that has no attributes or descriptive information, but only a single identifier or key.</strong></p>
<ul>
  <li>Used to simplify fact tables by eliminating the need for a separate dimension table.</li>
  <li>It can be still useful in the future, so we don’t just drop it.</li>
  <li>Examples: invoice number, billing number, order id, etc.</li>
  <li>with a suffix of <strong><code class="language-plaintext highlighter-rouge">_DD</code></strong></li>
</ul>

<p><img src="/assets/2023-12-19-data-warehouse-06/degenerate-dimensions.png" alt="" /></p>

<h1 id="junk-dimensions">Junk Dimensions</h1>

<p><strong>A Junk Dimension is a dimension with various flags or indicators with low cardinality.</strong></p>
<ul>
  <li>We call it <code class="language-plaintext highlighter-rouge">Junk Dimension</code> only internally. When talking to business users, we can refer to it as the “<strong>Transactional Indicator Dimension</strong>”.</li>
  <li>If there are too many combination cases for the attributes, extract only existing combinations of the fact table.</li>
</ul>

<blockquote>
  <p>💡 <code class="language-plaintext highlighter-rouge">Junk Dimension</code> is a concept in data warehousing that involves <strong>combining low-cardinality fields or attributes into a single-dimension table</strong>. These low-cardinality fields may represent different categories or flags that have a limited number of possible values. By consolidating these attributes into a single table, a Junk Dimension reduces the number of dimension tables in a data warehouse. <a href="https://www.dremio.com/wiki/junk-dimension/">(Source)</a></p>
</blockquote>

<p><img src="/assets/2023-12-19-data-warehouse-06/junk-dimensions.png" alt="" /></p>

<h1 id="role-playing-dimensions">Role-playing Dimensions</h1>

<p><strong>A Role-playing Dimension is a dimension that is referenced multiple times by a fact table.</strong></p>

<p><img src="/assets/2023-12-19-data-warehouse-06/role-playing-dimensions.png" alt="" /></p>

<p><strong>What are Role-playing Dimensions?</strong></p>
<ul>
  <li>Role-playing Dimensions are dimensions that are used more than once in a fact table, each time with a different meaning or role.</li>
  <li>They are typically derived from the same source dimension table, but with different aliases or prefixes to indicate their role.
    <ul>
      <li>For example, a date dimension table can be used to create <code class="language-plaintext highlighter-rouge">order_date</code>, <code class="language-plaintext highlighter-rouge">ship_date</code>, and <code class="language-plaintext highlighter-rouge">delivery_date</code> dimensions in a fact table that records product sales.</li>
      <li>Each of these dimensions has the same structure and attributes, such as <code class="language-plaintext highlighter-rouge">year</code>, <code class="language-plaintext highlighter-rouge">month</code>, <code class="language-plaintext highlighter-rouge">quarter</code>, <code class="language-plaintext highlighter-rouge">day</code>, etc., but they represent different aspects of the sales process.</li>
    </ul>
  </li>
</ul>

<p><strong>Why are Role-playing Dimensions challenging?</strong></p>
<ul>
  <li>(1) Increase the complexity and size of the fact table.
    <ul>
      <li>Each Role-playing Dimension adds more columns and joins to the fact table.</li>
    </ul>
  </li>
  <li>(2) Create confusion and inconsistency among users and analysts.
    <ul>
      <li>Different roles may have different meanings or interpretations for the same dimension attribute.</li>
    </ul>
  </li>
  <li>(3) Difficult to maintain and update.
    <ul>
      <li>Any change in the source dimension table may affect multiple Role-playing Dimensions and fact tables.</li>
    </ul>
  </li>
</ul>

<p><strong>How do you design Role-playing Dimensions?</strong></p>
<ul>
  <li>(1) Use a single-dimension table for each Role-playing Dimension and join it to the fact table using different foreign keys.
    <ul>
      <li><strong>Example</strong>: a date dimension table can be joined to a sales fact table using <code class="language-plaintext highlighter-rouge">order_date_key</code>, <code class="language-plaintext highlighter-rouge">ship_date_key</code>, and <code class="language-plaintext highlighter-rouge">delivery_date_key</code> as foreign keys.</li>
      <li><strong>Pros</strong>: simplicity and consistency</li>
      <li><strong>Cons</strong>: redundancy and performance issues (The same dimension table is duplicated and joined multiple times to the fact table.)</li>
    </ul>
  </li>
  <li>(2) Use a single dimension table for each Role-playing Dimension, but with different views or aliases to indicate their role.
    <ul>
      <li><strong>Example</strong>: a date dimension table can be viewed or aliased as <code class="language-plaintext highlighter-rouge">order_date</code>, <code class="language-plaintext highlighter-rouge">ship_date</code>, and <code class="language-plaintext highlighter-rouge">delivery_date</code> in the data warehouse schema, and joined to the fact table using the appropriate view or alias name.</li>
      <li><strong>Pros</strong>: reducing redundancy and improving performance (The same dimension table is not duplicated and joined multiple times to the fact table.)</li>
      <li><strong>Cons</strong>: complexity and dependency (The views or aliases need to be created and maintained in the data warehouse schema.)</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p><a href="https://www.linkedin.com/advice/3/how-do-you-deal-changing-business-requirements">Source</a></p>
</blockquote>

<hr />

<h2 id="published-by-joshua-kim"><em>Published by</em> Joshua Kim</h2>
<p><img src="/assets/profile/joshua-profile.png" alt="Joshua Kim" /></p>]]></content><author><name></name></author><category term="SQL" /><category term="Data Warehouse" /><summary type="html"><![CDATA[In this article, I’ll summarize key takeaways from: SECTION 06. Dimensions]]></summary></entry><entry><title type="html">Data Warehouse #05</title><link href="http://localhost:4000/data-warehouse-05/" rel="alternate" type="text/html" title="Data Warehouse #05" /><published>2023-12-06T00:00:00+09:00</published><updated>2023-12-06T00:00:00+09:00</updated><id>http://localhost:4000/data-warehouse-05</id><content type="html" xml:base="http://localhost:4000/data-warehouse-05/"><![CDATA[<blockquote>
  <p>In this article, I’ll summarize key takeaways from:</p>
  <ul>
    <li>SECTION 05. Facts</li>
  </ul>
</blockquote>

<h3 id="disclaimer">DISCLAIMER</h3>
<blockquote>
  <p>This article is a compilation of key takeaways after completing  <a href="https://www.udemy.com/course/data-warehouse-the-ultimate-guide/">Data Warehouse — The Ultimate Guide</a>  on Udemy. However, it may be challenging to achieve a comprehensive and deep understanding of Data Warehouse solely through this article. For your in-depth learning, please take the course, which is an excellent resource, and I personally highly recommend it to those who are eager to master data warehousing, dimensional modeling, and the ETL process.</p>
</blockquote>

<p><img src="/assets/2023-12-06-data-warehouse-05/data-warehouse.webp" alt="" /></p>
<blockquote>
  <p><a href="https://www.udemy.com/course/data-warehouse-the-ultimate-guide/">Source</a></p>
</blockquote>

<h1 id="additivity-in-facts">Additivity in Facts</h1>

<p><strong>1. Fully Additive Facts</strong></p>
<ul>
  <li>Can be added across  <strong>all dimensions</strong></li>
  <li>Most Flexible &amp; Useful</li>
  <li><strong>Most fact tables</strong>  are fully additive!</li>
</ul>

<p><strong>2. Semi-additive Facts</strong></p>
<ul>
  <li>Can be added across  <strong>a few dimensions</strong></li>
  <li>Less Flexible &amp; Used Carefully</li>
  <li><strong>Averaging</strong>  might be an alternative! (i.e.,  <strong>Balance</strong>)</li>
</ul>

<p><strong>3. Non-additive Facts</strong></p>
<ul>
  <li>Can  <strong>NOT</strong>  be added across  <strong>any dimensions</strong></li>
  <li>Limited Analytical</li>
  <li>Store the  <strong>underlying values</strong>  instead! (i.e.,  <strong>Ratio</strong>,  <strong>Percentage</strong>,  <strong>Price</strong>, etc.)</li>
</ul>

<h3 id="1-fully-additive-facts">1. Fully Additive Facts</h3>
<ul>
  <li>Given the tables below:</li>
</ul>

<p><img src="/assets/2023-12-06-data-warehouse-05/fully-additive-facts-1.webp" alt="" /></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">units</code>  are  <strong>additive</strong>.</li>
</ul>

<p><img src="/assets/2023-12-06-data-warehouse-05/fully-additive-facts-2.webp" alt="" /></p>

<h3 id="2-semi-additive-facts">2. Semi-additive Facts</h3>

<ul>
  <li>Given the tables below:</li>
</ul>

<p><img src="/assets/2023-12-06-data-warehouse-05/semi-additive-facts-1.webp" alt="" /></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">balance</code>  is  <strong>semi-additive</strong>.</li>
</ul>

<p><img src="/assets/2023-12-06-data-warehouse-05/semi-additive-facts-2.webp" alt="" /></p>

<h3 id="3-non-additive-facts">3. Non-additive Facts</h3>

<ul>
  <li>Given the tables below:</li>
</ul>

<p><img src="/assets/2023-12-06-data-warehouse-05/non-additive-facts-1.webp" alt="" /></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">price</code>  is  <strong>non-additive</strong>.</li>
</ul>

<p><img src="/assets/2023-12-06-data-warehouse-05/non-additive-facts-2.webp" alt="" /></p>

<h1 id="year-to-date-in-facts">Year-to-Date in Facts</h1>

<p><strong>Month-to-Date, Quarter-to-Date, Year-to-Date</strong></p>
<ul>
  <li>Often requested by business users</li>
  <li>Tempted to store them in columns</li>
  <li><strong>DO NOT store them in Fact Tables!</strong>
    <ul>
      <li>Instead, better store  <strong>the underlying values</strong>  in Fact Tables!</li>
    </ul>
  </li>
</ul>

<h1 id="types-of-fact-tables">Types of Fact Tables</h1>

<p><strong>1. Transactional Fact Tables</strong>
<strong>2. Periodic Snapshot Fact Tables</strong>
<strong>3. Accumulating Snapshot Fact Tables</strong></p>

<h3 id="1-transactional-fact-tables">1. Transactional Fact Tables</h3>

<ul>
  <li>1 Row = Measurement of 1 Event/Transaction</li>
  <li>It takes place at a specific time.</li>
  <li>One transaction defines the lowest grain.</li>
</ul>

<p><strong>Characteristics</strong></p>
<ul>
  <li>Most Common &amp; Very Flexible</li>
  <li>Typically Additive</li>
  <li>Other dimension tables associated ⬆️</li>
  <li>Size ⬆️⬆️</li>
</ul>

<p><img src="/assets/2023-12-06-data-warehouse-05/transactional-fact-tables.webp" alt="" /></p>

<h3 id="2-periodic-snapshot-fact-tables">2. Periodic Snapshot Fact Tables</h3>

<ul>
  <li>1 Row = Summarizes Measurement of Many Events/Transactions</li>
  <li>Summarized of standard period (i.e., 1 day, 1 week, etc.)</li>
  <li>One period defines the lowest grain.</li>
</ul>

<p><strong>Characteristics</strong></p>
<ul>
  <li>No Events = NULL or 0</li>
  <li>Typically Additive</li>
  <li>Other fact tables associated ⬆️ / Other dimension tables associated ⬇️</li>
  <li>Size ⬇️</li>
</ul>

<p><img src="/assets/2023-12-06-data-warehouse-05/periodic-snapshot-fact-tables.webp" alt="" /></p>

<h3 id="3-accumulating-snapshot-fact-tables">3. Accumulating Snapshot Fact Tables</h3>

<ul>
  <li>1 Row = Summarizes Measurement of Many Events/Transactions</li>
  <li>Summarized of the lifespan of 1 process (i.e., order fulfillment)</li>
  <li>Definite beginning &amp; Definite ending (with steps)</li>
</ul>

<p><strong>Characteristics</strong></p>
<ul>
  <li>Least Common</li>
  <li>Workflow or Process Analysis</li>
  <li>Multiple Datetime Foreign Keys (for each process step)</li>
  <li>Other Datetime dimension tables associated ⬆️⬆️⬆️</li>
  <li>Size ⬇️⬇️⬇️</li>
</ul>

<p><img src="/assets/2023-12-06-data-warehouse-05/accumulating-snapshot-fact-tables.webp" alt="" /></p>

<h1 id="steps-to-create-a-fact-table">Steps to Create a Fact Table</h1>

<p><img src="/assets/2023-12-06-data-warehouse-05/steps-to-create-a-fact-table.webp" alt="" /></p>

<h3 id="4-key-decisions">4 Key Decisions</h3>

<p><strong>1. Identify a business process for analysis.</strong></p>
<ul>
  <li>Examples: Sales, Order processing</li>
</ul>

<p><strong>2. Declare the grain.</strong></p>
<ul>
  <li>Examples: Transaction, Order, Order lines, Daily, Location</li>
</ul>

<p><strong>3. Identify relevant dimensions.</strong></p>
<ul>
  <li>“Filtering &amp; Grouping”</li>
  <li>“Soul” for Analysis</li>
  <li>Examples: Time, Locations, Product Category, Users</li>
</ul>

<p><strong>4. Identify facts for measurement.</strong></p>
<ul>
  <li>Defined by the grain! (Not by specific use cases)</li>
  <li>Examples: Revenue, Order Amount</li>
</ul>

<h1 id="factless-fact-tables">Factless Fact Tables</h1>

<p>Only dimensional aspects of an event are recorded.</p>
<ul>
  <li>How many employees have been registered last month?</li>
  <li>How many employees have been registered in a certain region?</li>
</ul>

<p>There are no measurement columns in the Factless Fact Tables.</p>

<p><img src="/assets/2023-12-06-data-warehouse-05/factless-fact-tables.webp" alt="" /></p>
<blockquote>
  <p><a href="https://learn.microsoft.com/ko-kr/power-bi/guidance/star-schema#factless-fact-tables">Source</a></p>
</blockquote>

<h1 id="natural-vs-surrogate-key">Natural vs. Surrogate Key</h1>

<h3 id="natural-key">Natural Key</h3>
<ul>
  <li>Comes out of the source system</li>
</ul>

<p><img src="/assets/2023-12-06-data-warehouse-05/natural-keys.webp" alt="" /></p>

<h3 id="surrogate-key">Surrogate Key</h3>
<ul>
  <li>Artificial Keys</li>
  <li>Integer Number</li>
  <li><code class="language-plaintext highlighter-rouge">_PK</code> or <code class="language-plaintext highlighter-rouge">_FK</code> suffixes</li>
  <li>Created by the Database or ETL Tool</li>
</ul>

<p><img src="/assets/2023-12-06-data-warehouse-05/surrogate-keys.webp" alt="" /></p>

<p><strong>Benefits of Surrogate Key</strong></p>
<ul>
  <li>Improve performance (Storage ⬇️, Easy Joins ⬆️)</li>
  <li>Handle dummy values such as NULLs or Missing Values (using 999 or -1)</li>
  <li>Integrate multiple source systems</li>
  <li>Easier Administration &amp; Updates</li>
  <li>Sometimes there are even NO Natural Keys available.</li>
</ul>

<p><strong>Practical Guidelines of Surrogate Key</strong></p>
<ul>
  <li>Always use Surrogate Keys in tables as Main PK and FK</li>
  <li>Use Surrogate Keys both for Fact &amp; Dimension Tables (Except the Date Dimension Tables)</li>
  <li>Optionally keep the Natural Keys</li>
</ul>

<h1 id="case-study-e-commerce">Case Study: E-commerce</h1>

<h3 id="data-collection">Data Collection</h3>
<ul>
  <li>Shopping Cart Checkouts</li>
</ul>

<p><img src="/assets/2023-12-06-data-warehouse-05/data-collection-1.webp" alt="" /></p>

<p><img src="/assets/2023-12-06-data-warehouse-05/data-collection-2.webp" alt="" /></p>

<h3 id="goals">Goals</h3>
<ul>
  <li>Maximizing Profits (profit margins, sales volume, product cost, promotions, and discounts)</li>
</ul>

<h3 id="1-identify-a-business-process-for-analysis">1. Identify a business process for analysis.</h3>
<ul>
  <li>Which products have been sold?</li>
  <li>How much is the sales profit?</li>
  <li>How much is the sales profit for each website?</li>
  <li>How much is the performance on each different day?</li>
  <li>What does the sales trend look like over time?</li>
</ul>

<h3 id="2-declare-the-grain">2. Declare the grain.</h3>
<ul>
  <li>The grains should have the most analytical values</li>
  <li>The grains should have the highest dimensionalities.</li>
  <li>In this case:  <code class="language-plaintext highlighter-rouge">order_id</code>  and  <code class="language-plaintext highlighter-rouge">product_id</code></li>
</ul>

<h3 id="3-identify-relevant-dimensions">3. Identify relevant dimensions.</h3>
<ul>
  <li>Dimensions should be the descriptive aspects of measures.</li>
  <li>Dimensions should be naturally derived after the grains are defined.</li>
  <li>In this case:  <code class="language-plaintext highlighter-rouge">customers</code>,  <code class="language-plaintext highlighter-rouge">products</code>,  <code class="language-plaintext highlighter-rouge">promotions</code>,  <code class="language-plaintext highlighter-rouge">datetimes</code>,  <code class="language-plaintext highlighter-rouge">websites</code></li>
</ul>

<p><img src="/assets/2023-12-06-data-warehouse-05/identify-relevant-dimensions.webp" alt="" /></p>

<h3 id="4-identify-facts-for-measurement">4. Identify facts for measurement.</h3>
<ul>
  <li>The facts must comply with the grains that we have defined above.</li>
  <li><code class="language-plaintext highlighter-rouge">discount</code>: additive vs. non-additive</li>
  <li><code class="language-plaintext highlighter-rouge">profit</code> : also complies with the grain</li>
</ul>

<p><img src="/assets/2023-12-06-data-warehouse-05/identify-facts-for-measurement.webp" alt="" /></p>

<h3 id="5-final-results">5. Final Results</h3>

<p><img src="/assets/2023-12-06-data-warehouse-05/final-results.webp" alt="" /></p>

<hr />

<h2 id="published-by-joshua-kim"><em>Published by</em> Joshua Kim</h2>
<p><img src="/assets/profile/joshua-profile.png" alt="Joshua Kim" /></p>]]></content><author><name></name></author><category term="SQL" /><category term="Data Warehouse" /><summary type="html"><![CDATA[In this article, I’ll summarize key takeaways from: SECTION 05. Facts]]></summary></entry><entry><title type="html">Data Warehouse #03</title><link href="http://localhost:4000/data-warehouse-03/" rel="alternate" type="text/html" title="Data Warehouse #03" /><published>2023-12-06T00:00:00+09:00</published><updated>2023-12-06T00:00:00+09:00</updated><id>http://localhost:4000/data-warehouse-03</id><content type="html" xml:base="http://localhost:4000/data-warehouse-03/"><![CDATA[<blockquote>
  <p>In this article, I’ll summarize key takeaways from:</p>
  <ul>
    <li>SECTION 03. Data Warehouse Architecture</li>
  </ul>
</blockquote>

<h3 id="disclaimer">DISCLAIMER</h3>

<blockquote>
  <p>This article is a compilation of key takeaways after completing  <a href="https://www.udemy.com/course/data-warehouse-the-ultimate-guide/">Data Warehouse — The Ultimate Guide</a>  on Udemy. However, it may be challenging to achieve a comprehensive and deep understanding of Data Warehouse solely through this article. For your in-depth learning, please take the course, which is an excellent resource, and I personally highly recommend it to those who are eager to master data warehousing, dimensional modeling, and the ETL process.</p>
</blockquote>

<p><img src="/assets/2023-12-06-data-warehouse-03/data-warehouse.webp" alt="" /></p>
<blockquote>
  <p><a href="https://www.udemy.com/course/data-warehouse-the-ultimate-guide/">Source</a></p>
</blockquote>

<h1 id="data-lake-vs-data-warehouse">Data Lake vs. Data Warehouse</h1>

<p><img src="/assets/2023-12-06-data-warehouse-03/data-lake-vs-data-warehouse.webp" alt="" /></p>

<h1 id="pentaho--postgresql">Pentaho &amp; PostgreSQL</h1>

<h3 id="pentaho">Pentaho</h3>

<ul>
  <li><strong>ETL Tool</strong></li>
  <li><a href="https://www.hitachivantara.com/en-us/products/pentaho-plus-platform/data-integration-analytics/pentaho-community-edition.html">Pentaho Community Edition Download</a></li>
  <li><code class="language-plaintext highlighter-rouge">pdi-ce-9.4.0.0-343.zip</code></li>
  <li>After unzipping the downloaded file, click the  <code class="language-plaintext highlighter-rouge">spoon</code>  file.</li>
</ul>

<h3 id="postgresql">PostgreSQL</h3>

<ul>
  <li><strong>Database Management System</strong></li>
  <li><a href="https://www.postgresql.org/download/">PostgreSQL Download</a></li>
  <li>After installing the downloaded file, run  <code class="language-plaintext highlighter-rouge">PGAdmin</code>.</li>
</ul>

<h1 id="the-layers-of-a-data-warehouse">The Layers of a Data Warehouse</h1>

<p><img src="/assets/2023-12-06-data-warehouse-03/The Layers of a Data Warehouse.webp" alt="" /></p>

<h3 id="data-sources--the-staging-layer">Data Sources → The Staging Layer</h3>
<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">E</code></strong> of ETL Process</li>
  <li><strong>“The Landing Zone Extracted Data”</strong>
    <ul>
      <li>Data in Tables and on a Separate Database</li>
      <li>As little “toughing” as possible</li>
      <li>We don’t charge the source systems.</li>
      <li>Temporary or Persistent Staging Layers</li>
    </ul>
  </li>
  <li>Short Time on the Source Systems</li>
  <li>Quickly Extracted</li>
  <li>Move the Data into Relational Database</li>
  <li>Start Transformations from There</li>
  <li>Minimal Transformation</li>
</ul>

<h3 id="the-staging-layer--the-cleansing-layer">The Staging Layer → The Cleansing Layer</h3>
<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">TL</code></strong> of ETL Process</li>
</ul>

<h3 id="the-cleansing-layer--core--access-layer--data-warehouse">The Cleansing Layer → Core / Access Layer / Data Warehouse</h3>
<ul>
  <li><strong>“Core”</strong>
    <ul>
      <li>Business Logic</li>
    </ul>
  </li>
</ul>

<h3 id="core--access-layer--data-warehouse--data-mart">Core / Access Layer / Data Warehouse → Data Mart</h3>
<ul>
  <li><strong>“Data Mart”</strong>
    <ul>
      <li>Subset of a Data Warehouse</li>
      <li>Dimensional Model</li>
      <li>Can be Further Aggregated.</li>
      <li>Usability + Acceptance</li>
      <li>Performance</li>
    </ul>
  </li>
  <li>Can Vary depending on Each Tool, Each Department, Each Region, Each Usecase</li>
</ul>

<h1 id="in-memory-databases">In-memory Databases</h1>

<h3 id="traditional-databases">Traditional Databases</h3>

<p><img src="/assets/2023-12-06-data-warehouse-03/traditional-databases.webp" alt="" /></p>

<h3 id="in-memory-databases-1">In-memory Databases</h3>

<p><img src="/assets/2023-12-06-data-warehouse-03/in-memory-databases.webp" alt="" /></p>

<ul>
  <li>Highly Optimized for Query Performance</li>
  <li>Good for Analytics &amp; High Query Volume</li>
  <li>Usually Used for Data Marts</li>
  <li>Relational &amp; Non-relational</li>
  <li>Techniques: Columnar Storage, Parallel Query Plans, and Others</li>
</ul>

<h1 id="demo-setting-up-the-staging-area-with-postgresql">Demo: Setting up the Staging Area with PostgreSQL</h1>

<p><img src="/assets/2023-12-06-data-warehouse-03/pgadmin4.webp" alt="" /></p>
<ul>
  <li>Created a  <strong>database</strong>  named  <code class="language-plaintext highlighter-rouge">DataWarehouseX</code>.</li>
  <li>Created a  <strong>schema</strong>  named  <code class="language-plaintext highlighter-rouge">Staging</code>.</li>
</ul>

<hr />

<h2 id="published-by-joshua-kim"><em>Published by</em> Joshua Kim</h2>
<p><img src="/assets/profile/joshua-profile.png" alt="Joshua Kim" /></p>]]></content><author><name></name></author><category term="SQL" /><category term="Data Warehouse" /><summary type="html"><![CDATA[In this article, I’ll summarize key takeaways from: SECTION 03. Data Warehouse Architecture]]></summary></entry><entry><title type="html">Data Warehouse #01-02</title><link href="http://localhost:4000/data-warehouse-01-02/" rel="alternate" type="text/html" title="Data Warehouse #01-02" /><published>2023-12-06T00:00:00+09:00</published><updated>2023-12-06T00:00:00+09:00</updated><id>http://localhost:4000/data-warehouse-01-02</id><content type="html" xml:base="http://localhost:4000/data-warehouse-01-02/"><![CDATA[<blockquote>
  <p>In this article, I’ll summarize key takeaways from:</p>
  <ul>
    <li>SECTION 01. Introduction</li>
    <li>SECTION 02. Data Warehouse Basics</li>
  </ul>
</blockquote>

<h3 id="disclaimer">DISCLAIMER</h3>

<blockquote>
  <p>This article is a compilation of key takeaways after completing  <a href="https://www.udemy.com/course/data-warehouse-the-ultimate-guide/">Data Warehouse — The Ultimate Guide</a>  on Udemy. However, it may be challenging to achieve a comprehensive and deep understanding of Data Warehouse solely through this article. For your in-depth learning, please take the course, which is an excellent resource, and I personally highly recommend it to those who are eager to master data warehousing, dimensional modeling, and the ETL process.</p>
</blockquote>

<p><img src="/assets/2023-12-06-data-warehouse-01-02/data-warehouse.webp" alt="" /></p>
<blockquote>
  <p><a href="https://www.udemy.com/course/data-warehouse-the-ultimate-guide/">Source</a></p>
</blockquote>

<h1 id="what-will-you-learn">What Will You Learn?</h1>

<ul>
  <li>Data Warehouse Basics</li>
  <li>Data Warehouse Architecture</li>
  <li>Dimensional Modeling</li>
  <li>Fact Tables</li>
  <li>Dimension Tables</li>
  <li>Slowly Changing Dimensions</li>
  <li>ETL Process</li>
  <li>ETL Tools</li>
  <li>Case Study: Create a Data Warehouse</li>
  <li>ETL vs. ELT</li>
  <li>Using a Data Warehouse</li>
  <li>Optimizing a Data Warehouse</li>
  <li>The Modern Data Warehouse</li>
</ul>

<h1 id="why-do-we-need-a-data-warehouse">Why Do We Need a Data Warehouse?</h1>

<p><img src="/assets/2023-12-06-data-warehouse-01-02/Why Do We Need a Data Warehouse.webp" alt="" /></p>

<h1 id="what-is-a-data-warehouse">What is a Data Warehouse?</h1>

<p>🗣️  <strong>A database used and optimized for analytical purposes.</strong></p>
<ul>
  <li>User-friendly</li>
  <li>Fast query performance</li>
  <li>Enabling data analysis</li>
</ul>

<h1 id="etl">ETL</h1>

<ul>
  <li><strong>Extract</strong>  +  <strong>Transform</strong>  +  <strong>Load</strong>  →  <strong><code class="language-plaintext highlighter-rouge">Data Warehouse</code></strong></li>
</ul>

<p><img src="/assets/2023-12-06-data-warehouse-01-02/etl-flowchart.webp" alt="" /></p>

<h1 id="goals-of-data-warehouse">Goals of Data Warehouse</h1>
<ul>
  <li>Centralized and Consistent Location for Data</li>
  <li>Data Must be Accessible Fast (<strong>Query Performance</strong>)</li>
  <li>User-friendly (<strong>Easy to Understand</strong>)</li>
  <li>Must Load Data Consistently and repeatedly (<strong>ETL</strong>)</li>
  <li><strong>Reporting</strong>  and  <strong>Data Visualization</strong>  Built on Top</li>
</ul>

<h1 id="understanding-a-data-warehouse">Understanding a Data Warehouse</h1>

<p><img src="/assets/2023-12-06-data-warehouse-01-02/data-warehouse-flowchart.webp" alt="" /></p>

<h1 id="business-intelligence">Business Intelligence</h1>
<ul>
  <li>We Create a Data Warehouse for  <strong>Business Intelligence</strong>!</li>
</ul>

<hr />

<h2 id="published-by-joshua-kim"><em>Published by</em> Joshua Kim</h2>
<p><img src="/assets/profile/joshua-profile.png" alt="Joshua Kim" /></p>]]></content><author><name></name></author><category term="SQL" /><category term="Data Warehouse" /><summary type="html"><![CDATA[In this article, I’ll summarize key takeaways from: SECTION 01. Introduction SECTION 02. Data Warehouse Basics]]></summary></entry><entry><title type="html">Data Warehouse #04</title><link href="http://localhost:4000/data-warehouse-04/" rel="alternate" type="text/html" title="Data Warehouse #04" /><published>2023-12-06T00:00:00+09:00</published><updated>2023-12-06T00:00:00+09:00</updated><id>http://localhost:4000/data-warehouse-04</id><content type="html" xml:base="http://localhost:4000/data-warehouse-04/"><![CDATA[<blockquote>
  <p>In this article, I’ll summarize key takeaways from:</p>
  <ul>
    <li>SECTION 04. Dimensional Modeling</li>
  </ul>
</blockquote>

<h3 id="disclaimer">DISCLAIMER</h3>
<blockquote>
  <p>This article is a compilation of key takeaways after completing  <a href="https://www.udemy.com/course/data-warehouse-the-ultimate-guide/">Data Warehouse — The Ultimate Guide</a>  on Udemy. However, it may be challenging to achieve a comprehensive and deep understanding of Data Warehouse solely through this article. For your in-depth learning, please take the course, which is an excellent resource, and I personally highly recommend it to those who are eager to master data warehousing, dimensional modeling, and the ETL process.</p>
</blockquote>

<p><img src="/assets/2023-12-06-data-warehouse-04/data-warehouse.webp" alt="" /></p>
<blockquote>
  <p><a href="https://www.udemy.com/course/data-warehouse-the-ultimate-guide/">Source</a></p>
</blockquote>

<h1 id="what-is-dimensional-modeling">What is Dimensional Modeling?</h1>

<p><strong>Dimensional Modeling</strong></p>
<ul>
  <li>Unique Technique of Structuring Data</li>
  <li>Commonly Used in Data Warehouse</li>
  <li>Optimized for Faster Data Regrieval</li>
  <li>Performance &amp; Usability Oriented</li>
  <li>Designed Reporting &amp; OLAP</li>
</ul>

<p><strong>Details</strong></p>
<ul>
  <li>It is the  <strong>Method of Organizing Data</strong>  in a Data Warehouse.</li>
  <li><code class="language-plaintext highlighter-rouge">Profit</code>  by  <code class="language-plaintext highlighter-rouge">Year</code>?  <code class="language-plaintext highlighter-rouge">Profit</code>  by  <code class="language-plaintext highlighter-rouge">Category</code>?
    <ul>
      <li><strong>Facts</strong>:  <strong>Measurements</strong>  like  <code class="language-plaintext highlighter-rouge">Profit</code></li>
      <li><strong>Dimensions</strong>:  <strong>Contexts</strong>  like  <code class="language-plaintext highlighter-rouge">Period</code>  or  <code class="language-plaintext highlighter-rouge">Category</code></li>
    </ul>
  </li>
</ul>

<p><img src="/assets/2023-12-06-data-warehouse-04/star-schema.webp" alt="" /></p>

<h1 id="why-is-dimensional-modeling">Why is Dimensional Modeling?</h1>

<ul>
  <li>Dimensional Modeling → <code class="language-plaintext highlighter-rouge">Performance</code> ⬆️ / <code class="language-plaintext highlighter-rouge">Usability</code> ⬆️</li>
</ul>

<p><img src="/assets/2023-12-06-data-warehouse-04/dimensional-modeling.webp" alt="" /></p>

<h1 id="facts">Facts</h1>

<p><strong>Facts</strong> usually…</p>
<ul>
  <li>Aggregatable (with Numeric Values)</li>
  <li>Measurable</li>
  <li>Event or Transactional Data</li>
  <li>Date or Time in a Fact Table</li>
  <li>Foundation of Data Warehouse</li>
  <li>Key Measurements</li>
  <li>Aggregated and Analyzed</li>
</ul>

<h1 id="dimensions">Dimensions</h1>

<p><strong>Dimensions</strong> usually…</p>
<ul>
  <li>Non-aggregatable</li>
  <li>Descriptive</li>
  <li>More Static than Facts</li>
  <li>Categorizes Facts</li>
  <li>Supportive &amp; Descriptive</li>
  <li>Filtering, Grouping, and Labeling</li>
</ul>

<p><img src="/assets/2023-12-06-data-warehouse-04/star-vs-snowflake.webp" alt="" /></p>
<blockquote>
  <p><a href="https://nidhig631.medium.com/star-schema-vs-snowflake-schema-78dc9424a8a2">Source</a></p>
</blockquote>

<p><strong>Star Schema</strong></p>
<ul>
  <li>Most Common Schema in Data Mart</li>
  <li>Simplest Form (vs. Snowflake Schema)</li>
  <li>Works Best for Specific Needs (Simple Queries vs. Complex Queries)</li>
  <li>Usability + Query Performance (<code class="language-plaintext highlighter-rouge">Read</code>)</li>
</ul>

<p><strong>Denormalized</strong> (= Star Schema)</p>
<ul>
  <li>Data Redundancy ⬆️</li>
  <li>Optimized to get data out ⬆️</li>
  <li>Query Performance (<code class="language-plaintext highlighter-rouge">Read</code>) ⬆️</li>
  <li>User Experience ⬆️</li>
</ul>

<p><strong>Normalized</strong> (= Snowflake Schema)</p>
<ul>
  <li>Data Redundancy ⬇️</li>
  <li>Storage ⬇️</li>
  <li>Query Performance (<code class="language-plaintext highlighter-rouge">Write &amp; Update</code>) ⬆️</li>
  <li>Number of Tables ⬆️</li>
  <li>Joins Necessary ⬆️</li>
</ul>

<h1 id="snowflake-schema">Snowflake Schema</h1>

<p><strong>Advantages</strong></p>
<ul>
  <li>Storage Cost ⬇️</li>
  <li>Data Redundancy ⬇️</li>
  <li>Query Performance (<code class="language-plaintext highlighter-rouge">Write &amp; Update</code>) ⬆️</li>
</ul>

<p><strong>Disadvantages</strong></p>
<ul>
  <li>Complex Queries with Joins</li>
  <li>Query Performance (<code class="language-plaintext highlighter-rouge">Read</code>) ⬇️</li>
</ul>

<p><strong>Star Schema vs. Snowflake Schema</strong></p>
<ul>
  <li><strong>Data Mart</strong>  →  <code class="language-plaintext highlighter-rouge">Star Schema</code>  is Preferred!</li>
  <li><strong>Core</strong>  →  <code class="language-plaintext highlighter-rouge">Star Schema</code>  is Preferred, but  <code class="language-plaintext highlighter-rouge">Snowflake Schema</code>  can be considered!</li>
</ul>

<h1 id="demo-product--category-dimensions-snowflake-schema">Demo: Product &amp; Category Dimensions (<code class="language-plaintext highlighter-rouge">Snowflake Schema</code>)</h1>

<p>(1) With  <code class="language-plaintext highlighter-rouge">products.csv</code>, we are now trying to create a “<strong>Category Dimension</strong>” using PostgreSQL!</p>

<p><img src="/assets/2023-12-06-data-warehouse-04/products-csv.webp" alt="" /></p>

<p>(2) In PGAdmin, Click “<code class="language-plaintext highlighter-rouge">Query Tool</code>” on the  <strong>public schema</strong>.</p>

<p><img src="/assets/2023-12-06-data-warehouse-04/query-tool.webp" alt="" /></p>

<p>(3) Run the code block to create  <code class="language-plaintext highlighter-rouge">products</code>  table, then you’ll see the table has been created.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">products</span> <span class="p">(</span>  
    <span class="n">product_id</span> <span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span>  
    <span class="n">product_name</span> <span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">100</span><span class="p">),</span>  
    <span class="n">category</span> <span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">50</span><span class="p">),</span>  
    <span class="n">subcategory</span> <span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">50</span><span class="p">)</span>  
<span class="p">);</span>
</code></pre></div></div>

<p><img src="/assets/2023-12-06-data-warehouse-04/public.webp" alt="" /></p>

<p>(4) Right-click on the  <code class="language-plaintext highlighter-rouge">products</code>  table, then click “<strong>Import/Export Data</strong>” button.</p>

<p><img src="/assets/2023-12-06-data-warehouse-04/import-export-data.webp" alt="" /></p>

<p>(5) Designate the  <strong>products.csv</strong>  file to import on  <code class="language-plaintext highlighter-rouge">products</code>  table.</p>

<p><img src="/assets/2023-12-06-data-warehouse-04/import.webp" alt="" /></p>

<p><img src="/assets/2023-12-06-data-warehouse-04/options.webp" alt="" /></p>

<p><img src="/assets/2023-12-06-data-warehouse-04/columns.webp" alt="" /></p>

<p>(6) Run the code block to see if your data has been imported.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">products</span><span class="p">;</span>
</code></pre></div></div>

<p><img src="/assets/2023-12-06-data-warehouse-04/data-output.webp" alt="" /></p>

<p>(7) Run the code block to see what kind of unique  <strong>category</strong>  is in  <code class="language-plaintext highlighter-rouge">products</code>  table.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span>  
    <span class="k">DISTINCT</span> <span class="n">category</span>  
<span class="k">FROM</span> <span class="n">products</span><span class="p">;</span>
</code></pre></div></div>

<p><img src="/assets/2023-12-06-data-warehouse-04/data-output-category.webp" alt="" /></p>

<p>(8) Run the code block to create a dimension table named  <code class="language-plaintext highlighter-rouge">categories</code>.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span>  
    <span class="n">ROW_NUMBER</span><span class="p">()</span> <span class="n">OVER</span> <span class="p">(</span><span class="k">ORDER</span> <span class="k">BY</span> <span class="n">category</span><span class="p">)</span> <span class="k">AS</span> <span class="n">category_id</span><span class="p">,</span>  
    <span class="n">category</span>  
<span class="k">INTO</span> <span class="n">categories</span>  
<span class="k">FROM</span> <span class="p">(</span>  
    <span class="k">SELECT</span> <span class="k">DISTINCT</span> <span class="n">category</span>  
    <span class="k">FROM</span> <span class="n">products</span>  
<span class="p">)</span> <span class="n">SUB</span>  
<span class="p">;</span>
</code></pre></div></div>

<p>(9) See if the  <code class="language-plaintext highlighter-rouge">categories</code>  table has been created.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">categories</span><span class="p">;</span>
</code></pre></div></div>

<p><img src="/assets/2023-12-06-data-warehouse-04/data-output-category-id.webp" alt="" /></p>

<hr />

<h2 id="published-by-joshua-kim"><em>Published by</em> Joshua Kim</h2>
<p><img src="/assets/profile/joshua-profile.png" alt="Joshua Kim" /></p>]]></content><author><name></name></author><category term="SQL" /><category term="Data Warehouse" /><summary type="html"><![CDATA[In this article, I’ll summarize key takeaways from: SECTION 04. Dimensional Modeling]]></summary></entry><entry><title type="html">『마스터링 이더리움』 중요한 내용 모조리 요약</title><link href="http://localhost:4000/mastering-ethereum/" rel="alternate" type="text/html" title="『마스터링 이더리움』 중요한 내용 모조리 요약" /><published>2023-12-05T00:00:00+09:00</published><updated>2023-12-05T00:00:00+09:00</updated><id>http://localhost:4000/mastering-ethereum</id><content type="html" xml:base="http://localhost:4000/mastering-ethereum/"><![CDATA[<blockquote>
  <p>개발적인 용어가 난무해서 당시에는 도저히 펼쳐 볼 엄두가 안 났지만, 이 업계에서 약 3년 가까이 구르다보니 어느 정도 잘 읽히게 되었다. 그래서 2023년 1월 1일 새해 목표 중 하나로 “<strong>마스터링 이더리움 완독하고 정리하기</strong>”를 세우게 되었다. 그리고 약 1개월 만에 다 읽게 되었다.</p>
</blockquote>

<h3 id="contents">CONTENTS</h3>
<ol>
  <li>들어가는 글</li>
  <li>주의사항</li>
  <li><strong>[Chapter 01–02]</strong> What is Ethereum? &amp; Intro to Ethereum</li>
  <li><strong>[Chapter 03]</strong> Ethereum Clients</li>
  <li><strong>[Chapter 04]</strong> Cryptography</li>
  <li><strong>[Chapter 05]</strong> Wallets</li>
  <li><strong>[Chapter 06]</strong> Transactions</li>
  <li><strong>[Chapter 07]</strong> Smart Contracts &amp; Solidity</li>
  <li><strong>[Chapter 08]</strong> Smart Contracts &amp; Vyper</li>
  <li><strong>[Chapter 09]</strong> Smart Contracts &amp; Security</li>
  <li><strong>[Chapter 10]</strong> Tokens</li>
  <li><strong>[Chapter 11]</strong> Oracles</li>
  <li><strong>[Chapter 12]</strong> Decentralized Applications (dApps)</li>
  <li><strong>[Chapter 13]</strong> Ethereum Virtual Machine (EVM)</li>
  <li><strong>[Chapter 14]</strong> Consensus</li>
</ol>

<hr />

<h3 id="disclaimer">DISCLAIMER</h3>
<p>본 아티클은 작성자의 전/현직 기업의 사업 내용과 전혀 관련이 없으며, 개인적인 학습을 통해 작성한 것임을 밝힙니다.</p>

<p><img src="/assets/2023-12-05-mastering-ethereum/textbook.webp" alt="" /></p>
<blockquote>
  <p><a href="https://product.kyobobook.co.kr/detail/S000001916933">Source</a></p>
</blockquote>

<h1 id="1-들어가는-글">1. 들어가는 글</h1>

<p>때는 2021년 3월, 블록체인과 가상자산에 대해 무지몽매한 상태로 업계에 처음 발을 들였다. 생소한 블록체인 기술과 아키텍처를 이해하려고 노력해도 도무지 감이 안 잡혀서 고통스럽기도 했다. 많은 것을 의지했던 당시 옆 자리 선배님의 책상에는 마스터링 이더리움 책이 놓여 있었다.</p>

<blockquote>
  <p>“이 책이 제일 좋아요. 그런데 그만큼 엄청 어려워요.”</p>
</blockquote>

<p>개발적인 용어가 난무해서 당시에는 도저히 펼쳐 볼 엄두가 안 났지만, 이 업계에서 약 3년 가까이 구르다보니 어느 정도 잘 읽히게 되었다. 그래서 2023년 1월 1일 새해 목표 중 하나로 “<strong>마스터링 이더리움 완독하고 정리하기</strong>”를 세우게 되었다. 그리고 약 1개월 만에 다 읽게 되었다.</p>

<h1 id="2-주의사항">2. 주의사항</h1>

<ul>
  <li>개발을 위한 소스 코드 내용이나 암호학 이론 등 지나치게 깊은 내용은 Skimming하여 정리했다.</li>
  <li>개발자는 아니지만 프로그래밍과 데이터에 대한 이해를 하고 있는 입장에서, 완벽하지는 않지만 그래도 나름 잘 정리해봤다.</li>
  <li>이더리움의 바이블이라고 불리는 이 책을 직접 읽기에는 부담을 느끼시는 분들께서 빠르게 훑어보고 싶을 때 유용하게 쓰실 수 있기를 바란다.</li>
  <li>내용을 요약하는 과정에서 오류가 있을 수 있으므로, 정확한 레퍼런스는 반드시 본서를 참고해주시기를 바란다.</li>
</ul>

<h1 id="3-chapter-0102-what-is-ethereum--intro-to-ethereum">3. [Chapter 01–02] What is Ethereum? &amp; Intro to Ethereum</h1>

<p>비트코인의 스크립트(Script) 언어가 의도적으로 지불 조건에 대한 단순한 True/False 평가에만 제한되어 있는 반면, 이더리움 언어는 튜링 완전 언어다. 이것은 이더리움이 범용 컴퓨터로 직접 작동할 수 있음을 의미한다.</p>

<p>여러 블록체인의 성격을 파악하기 위해  <strong>개방성</strong>,  <strong>공공성</strong>,  <strong>국제화</strong>,  <strong>탈중앙화</strong>,  <strong>중립성</strong>,  <strong>검열저항성</strong>  등의 평가 기준이 필요하다.</p>

<p>이더리움은 탈중앙화된 State Machine으로서, Key-Value Tuple로 표현할 수 있는 모든 데이터를 저장할 수 있는 저장소의 상태 전이(State Change)를 추적한다.</p>

<p><img src="/assets/2023-12-05-mastering-ethereum/state-change.webp" alt="" /></p>
<blockquote>
  <p><a href="https://takenobu-hs.github.io/downloads/ethereum_evm_illustrated.pdf">Source</a></p>
</blockquote>

<p>이더리움 상태 전이는 Bytecode를 실행하는 스택 기반 가상머신인 EVM에 의해 처리된다.</p>

<p>스마트 컨트랙트라는 EVM 프로그램은:</p>

<ul>
  <li>고수준 언어인 Solidity로 작성되고,</li>
  <li>EVM에서 실행되도록 Bytecode로 컴파일된다.</li>
</ul>

<p>이더리움의 State는 트랜잭션 및 시스템 상태가 머클 패트리샤 트리(<a href="https://ethereum.org/en/developers/docs/data-structures-and-encoding/patricia-merkle-trie/">MERKLE PATRICIA TRIE</a>)라고 하는 시리얼라이즈된 해시 데이터 구조로, 각 노드의 DB에 저장된다.</p>

<p><img src="/assets/2023-12-05-mastering-ethereum/merkle-patricia-trie.webp" alt="" /></p>
<blockquote>
  <p><a href="https://medium.com/codechain/modified-merkle-patricia-trie-how-ethereum-saves-a-state-e6d7555078dd">Source</a></p>
</blockquote>

<p>사실 암호화폐 기능은 탈중앙화된 월드 컴퓨터로서의 이더리움 기능에 부차적인 것이다.</p>

<ul>
  <li>ETH는 EVM이라고 하는 에뮬레이트된 컴퓨터에서 실행되는 컴퓨터 프로그램인 스마트 컨트랙트를 실행하는 데 사용되기 위한 것이다.</li>
</ul>

<p>EOA만 트랜잭션를 시작(Initiate)할 수 있고, 컨트랙트는 복잡한 실행 경로를 구축하여 다른 컨트랙트를 호출해서 반응(React)할 수 있다. 이것을 사용하는 전형적인 방법은 Multi-sig 스마트 트랜잭션 지갑에 지급 요청 트랜잭션을 전송하여 일부 ETH를 다른 주소로 보내는 것이다.</p>

<p><img src="/assets/2023-12-05-mastering-ethereum/eoa-ca.webp" alt="" /></p>
<blockquote>
  <p><a href="https://takenobu-hs.github.io/downloads/ethereum_evm_illustrated.pdf">Source</a></p>
</blockquote>

<ul>
  <li><strong>EOA</strong>  (Externally Owned Account): 트랜잭션을 시작할 수 있음</li>
  <li><strong>CA</strong>  (Contract Account): EOA의 함수 호출에 의해 반응할 수 있음</li>
</ul>

<p>블록체인에 컨트랙트를 배포</p>
<ul>
  <li>목적지 주소가  <code class="language-plaintext highlighter-rouge">0x00…0</code>인 특수 트랜잭션을 만드는 것</li>
</ul>

<p>컨트랙트에서 시작된 Internal Transaction은 Message라고도 한다.</p>

<h1 id="4-chapter-03-ethereum-clients">4. [Chapter 03] Ethereum Clients</h1>

<p>블록체인의 건전성, 복원력, 검열저항 특성은 독립적으로 운용되고 지리적으로 분산된 Full Nodes가 얼마나 많은지에 달려 있다.</p>

<p><img src="/assets/2023-12-05-mastering-ethereum/clients.webp" alt="" /></p>
<blockquote>
  <p><a href="https://ethereum.org/en/developers/docs/nodes-and-clients/client-diversity/">Source</a></p>
</blockquote>

<h1 id="5-chapter-04-cryptography">5. [Chapter 04] Cryptography</h1>

<p>타원 곡선 산술에서 소수로 나눈 나머지를 곱하는 것은 간단하지만, 나눗셈은 사실상 불가능하다. 이것을 이산로그문제라고 하며, 현재는 알려진 트랩도어는 없다.</p>

<p>타원 곡선 암호화는 최신 컴퓨터 시스템에서 광범위하게 활용되며, 이더리움에서 개인키와 디지털 서명을 사용하는 기초가 된다.</p>

<p>이더리움 공개키는 타원 곡선에 있는 점으로, 타원 곡선 방정식을 만족하는 x와 y 좌표의 집합을 의미한다.</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">공개키(K) = 개인키(k) * G(generator point)</code>
    <ul>
      <li>(여기에서 *은 일반적인 곱셈이 아닌, 특수 타원 곡선 곱하기 연산)</li>
    </ul>
  </li>
</ul>

<h1 id="6-chapter-05-wallets">6. [Chapter 05] Wallets</h1>

<p><img src="/assets/2023-12-05-mastering-ethereum/key-flowchart.webp" alt="" /></p>
<blockquote>
  <p>작성자: Joshua</p>
</blockquote>

<p>지갑은 보유 중인 Private Key들이 서로 관련이 있느냐 없느냐에 따라 비결정적 지갑과 결정적 지갑으로 구분된다.</p>

<ul>
  <li><strong>비결정적 지갑</strong>: 각기 다른 무작위 수로부터 각 Private Key를 무작위적으로 추출한다.</li>
</ul>

<p><img src="/assets/2023-12-05-mastering-ethereum/비결정적-지갑.webp" alt="" /></p>
<blockquote>
  <p><a href="http://wiki.hash.kr/index.php/HD_%EC%A7%80%EA%B0%91">Source</a></p>
</blockquote>

<ul>
  <li><strong>결정적 지갑</strong>: 모든 Private Key가 단일 마스터 키인 seed로부터 파생된다. seed는 단어 목록인 니모닉 코드 단어로 인코딩되어 불의의 사고에 대비할 수 있다.</li>
</ul>

<p><img src="/assets/2023-12-05-mastering-ethereum/결정적-지갑.webp" alt="" /></p>
<blockquote>
  <p><a href="http://wiki.hash.kr/index.php/HD_%EC%A7%80%EA%B0%91">Source</a></p>
</blockquote>

<ul>
  <li>(참고) <a href="http://wiki.hash.kr/index.php/HD_%EC%A7%80%EA%B0%91"><strong>HD 지갑</strong></a>: 결정적 지갑은 단일 시드에서 많은 키를 쉽게 유도하기 위해 만들어졌다. 현재 가장 진보한 형태의 결정적 지갑은 비트코인의 BIP32 표준으로 정의된 HD 지갑이다. HD 지갑은 부모 키가 연속된 자식 키를 유도할 수 있고, 각각의 자식키는 손자 키를 유도할 수 있는 구조인 트리 구조로 파생된 키를 포함한다. 이러한 구조는 부모 키가 자식 키의 시퀀스를 유도할 수 있고, 각각의 자식은 다시 또 손자 키의 시퀀스를 유도할 수 있다. HD 지갑은 결정적 지갑에 비해 몇 가지 장점이 있다. 먼저 HD 지갑의 트리 구조는 예를 들어, 특정 서브 키의 특정 분기는 입금을 위해 사용하고, 다른 브랜치는 출금의 잔돈을 받기 위해 사용할 수 있다. 또한 부서, 자회사, 특정 기능 또는 회계 카테고리로 다른 분기를 할당하여 기업 설정과 같은 구조적인 의미를 표현하는 데도 사용할 수 있다. HD 지갑의 또 다른 장점은 사용자가 개인키에 접근하지 않고, 연속된 공개키를 생성할 수 있는 것이다. HD 지갑은 보안상 안전하지 않은 서버, 보기 전용, 수신 전용의 용도로 사용할 수 있는데, 이때 지갑에는 자금을 움직이는 개인키가 들어 있지 않게 만들 수 있다.</li>
</ul>

<p><img src="/assets/2023-12-05-mastering-ethereum/HD-지갑.webp" alt="" /></p>
<blockquote>
  <p><a href="http://wiki.hash.kr/index.php/HD_%EC%A7%80%EA%B0%91">Source</a></p>
</blockquote>

<h1 id="7-chapter-06-transactions">7. [Chapter 06] Transactions</h1>

<p>이더리움은 Global Singleton State Machine이며, 트랜잭션은 이 State Machine을 움직여서 상태를 변경할 수 있도록 만든다.</p>

<p>트랜잭션은 다음 데이터를 포함하는 serialized binary message다.</p>

<p><img src="/assets/2023-12-05-mastering-ethereum/transaction.webp" alt="" /></p>
<blockquote>
  <p><a href="https://takenobu-hs.github.io/downloads/ethereum_evm_illustrated.pdf">Source</a></p>
</blockquote>

<ul>
  <li><strong>nonce</strong>,  <strong>gas price</strong>,  <strong>gas limit</strong>,  <strong>recipient</strong>,  <strong>value</strong>,  <strong>data</strong>,  <strong>v</strong>,  <strong>r</strong>,  <strong>s</strong></li>
</ul>

<p>트랜잭션 메시지 구조는 RLP(Recursive Length Prefix) 인코딩 체계를 사용하여 serialize된다.</p>

<p><img src="/assets/2023-12-05-mastering-ethereum/rlp.webp" alt="" /></p>
<blockquote>
  <p>작성자: Joshua</p>
</blockquote>

<p>(1)  <strong>Nonce</strong>: 해당 address에서 보낸 tx 건수 OR 컨트랙트 생성 건수 (scalar value). 사용상의 기능 및 트랜잭션 복제 방지의 효과를 지님.</p>

<p>(2)  <strong>Gas Price &amp; Limit</strong>: DoS 공격이나 실수로 막대한 자원을 소모하는 tx를 피하기 위한 metering 역할을 함.</p>

<p><img src="/assets/2023-12-05-mastering-ethereum/gas.webp" alt="" /></p>
<blockquote>
  <p><a href="https://ethereum.org/en/developers/docs/transactions/">Source</a></p>
</blockquote>

<p>(3)  <strong>Recipient</strong>: 이더리움은 to_address의 유효성을 검증하지 않는다. 이 유효성 검정은 사용자 인터페이스 수준에서 수행되어야 함.</p>
<ul>
  <li>recipient를 zero address(<code class="language-plaintext highlighter-rouge">0x00…0</code>)로 두면, 컨트랙트 생성 트랜잭션을 의미함</li>
</ul>

<p>(4)  <strong>value &amp; data</strong>: value는 지급량, data는 호출. EOA나 CA에 지급량 혹은 호출에 필요한 data payload를 전달함.</p>

<p>(5)  <strong>v, r, s</strong>: r과 s는 tx 메시지에 private key로 서명한 결과값. v는 서명을 확인하는 데 도움이 되는 복구 식별자와 chain id.</p>

<p><strong>트랜잭션 서명 프로세스</strong></p>
<ul>
  <li>(1) nonce, gasPrice, gasLimit, to, value, data, chainID, 0, 0의 9개 필드를 포함하는 tx 데이터 구조를 만든다.</li>
  <li>(2) RLP로 인코딩하여 serialized message를 생성한다.</li>
  <li>(3) serialized message를 Keccak-256 해시를 리턴한다.</li>
  <li>(4) 리턴된 해시를 private key로 ECDSA 서명을 계산한다.</li>
  <li>(5) 계산된 결과를 message의 v, r, s에 추가한다.</li>
</ul>

<p><strong>서명 및 전송 분리 (Offline Signing)</strong></p>

<ul>
  <li>Unsigned tx msg를 온라인에서 생성, 오프라인에서 private key를 통해 Sign하여 Signed tx msg를 온라인에 전달, 온라인에서 네트워크로 flood.</li>
</ul>

<p><img src="/assets/2023-12-05-mastering-ethereum/offline-signing.webp" alt="" /></p>
<blockquote>
  <p>작성자: Joshua</p>
</blockquote>

<p><strong>트랜잭션 전파</strong></p>
<ul>
  <li>(1) flood routing 프로토콜을 사용한다.</li>
  <li>(2) 각 노드는 적어도 13개의 다른 노드에 대한 연결을 유지한다.</li>
  <li>(3) 트랜잭션을 생성한 ‘직접’ 연결된 다른 모든 노드로 전송된다.</li>
  <li>(4) 각 노드의 관점에서 보면, 수신된 tx의 출처를 식별할 수 없다. 발신한 노드는 tx의 생성자일 수도 있고, 똑같은 tx 수신자일 수도 있기 때문이다.</li>
  <li>(5) 비트코인은 multi-sig 계정을 만들 수 있지만, 이더리움의 기본 EOA에는 multi-sig 기능이 없다. 컨트랙트 계정을 생성하여 multi-sig을 구현해야 한다.</li>
  <li>(6) 컨트랙트를 통해 더욱 다양한 형태의 multi-sig를 구현할 수 있다는 측면에서 유연성이 있지만, 컨트랙트 코드 자체에 의해 보안 취약점이 발생할 수 있으므로, multi-sig를 컨트랙트 수준이 아닌, EVM 수준에서 처리하게 하자는 제안이 많다.</li>
</ul>

<h1 id="8-chapter-07-smart-contracts--solidity">8. [Chapter 07] Smart Contracts &amp; Solidity</h1>

<p>컨트랙트 계정은 개인키를 갖지 않으므로 스마트 컨트랙트에 규정된 미리 결정된 방식으로 ‘스스로 제어’하는 반면, EOA는 프로토콜의 외부의 독립적인 ‘실제 세계’의 개인키로 생성되고 암호로 서명된 거래에 의해 제어된다.</p>
<ul>
  <li><strong>스마트 컨트랙트</strong>: 이더리움 네트워크 프로토콜(탈중앙화된 이더리움 월드 컴퓨터)의 일부인 EVM 컨텍스트 상에서 결정론적으로(deterministically) 작동하는 불변적인(immutable) 컴퓨터 프로그램</li>
</ul>

<p><strong>컨트랙트 생성</strong></p>
<ul>
  <li>컨트랙트 생성 트랜잭션은 고유한 컨트랙트 생성 주소, 즉  <code class="language-plaintext highlighter-rouge">0x0</code>으로 전송된다.</li>
  <li>컨트랙트 생성자는 프로토콜 수준에서 특별한 권한을 얻지 못한다. (스마트 컨트랙트 계정을 위한 개인키가 없기 때문)</li>
</ul>

<p>오류로 인해 컨트랙트 실행이 실패하면 모든 상태 변경은 트랜잭션이 실행되지 않은 것처럼 롤백(rolled back)된다.</p>

<p><strong>컨트랙트 삭제</strong></p>
<ul>
  <li>컨트랙트를 ‘삭제’하여 해당 주소에서 코드와 내부 상태를 제거하고 빈 계정으로 남길 수 있다. (<strong>SELFDESTRUCT</strong>) 이 작업은 Negative Gas, 즉 가스 환불이 일어나기 때문에 저장된 상태의 삭제로 인한 네트워크 클라이언트 자원을 반환하도록 하는 동기부여를 만든다.</li>
</ul>

<p>EVM은 x86_64 같은 머신 코드를 실행하는 컴퓨터의 CPU와 유사한 EVM Bytecode라는 특수한 형태의 코드를 실행하는 가상 머신이다.</p>

<p><img src="/assets/2023-12-05-mastering-ethereum/evm.webp" alt="" /></p>
<blockquote>
  <p><a href="https://takenobu-hs.github.io/downloads/ethereum_evm_illustrated.pdf">Source</a></p>
</blockquote>

<p><strong>Solidity 프로젝트의 주된 기능</strong></p>
<ul>
  <li>Solidity 언어로 작성된 프로그램을 EVM Bytecode로 변환하는 컴파일러인 solc이다.</li>
  <li>이더리움 스마트 컨트랙트를 위한 중요한 ABI(Application Binary Interface) 표준을 관리한다.</li>
</ul>

<p><strong>ABI (Application Binary Interface)</strong></p>
<ul>
  <li>ABI는 데이터 구조와 함수가 어떻게 기계 코드에서 사용되는지 그 방법을 정의한다. 즉, 기계 코드와 데이터를 교환하기 위해 인코딩 및 디코딩하는 기본 방법이다.</li>
  <li>이더리움에서 ABI는 EVM에서 컨트랙트 호출을 인코딩하고 트랜잭션에서 데이터를 읽는 데 사용된다.</li>
  <li>ABI의 목적은 컨트랙트에서 호출할 수 있는 함수를 정의하고 각 함수가 인수를 받아들이고 결과를 반환하는 방법을 설명하는 것이다.</li>
  <li>컨트랙트의 ABI는 함수 설명 및 이벤트의 JSON 배열로 지정된다.</li>
  <li>애플리케이션이 컨트랙트와 상호작용하는 데 필요한 것: ABI + 컨트랙트 주소</li>
</ul>

<p><strong>스마트 컨트랙트를 만들 때 함수 호출의 가스 비용을 최소화하기 위해 권장하는 지침</strong></p>
<ul>
  <li>(1) Dynamic Array 피하기</li>
  <li>(2) 다른 컨트랙트 호출 피하기</li>
</ul>

<h1 id="9-chapter-08-smart-contracts--vyper">9. [Chapter 08] Smart Contracts &amp; Vyper</h1>
<p>Chapter 07 솔리디티 편을 정독하는 것만으로 충분하다고 판단하여 과감히 생략함</p>

<h1 id="10-chapter-09-smart-contracts--security">10. [Chapter 09] Smart Contracts &amp; Security</h1>
<p>지나치게 개발과 보안적인 내용이라고 판단하여 과감히 생략함</p>

<h1 id="11-chapter-10-tokens">11. [Chapter 10] Tokens</h1>

<p><strong>ETH vs Token 잔액 비교</strong></p>
<ul>
  <li>이더리움 계정의 ETH 잔액은  <strong>프로토콜 수준</strong>에서 처리되는 반면,</li>
  <li>이더리움 계정의 Token 잔액은  <strong>컨트랙트 수준</strong>에서 처리된다.</li>
  <li>따라서 이더리움 프로토콜은 Token에 대해 아무것도 모른다.</li>
</ul>

<p>이더리움에서 새 Token을 만들려면 새로운 컨트랙트를 만들어야 한다. 배포된 컨트랙트는 Token의 소유권, 이전 및 접근 권한을 포함한 모든 것을 처리한다.</p>

<h2 id="erc20-tokens"><strong>ERC20 Tokens</strong></h2>

<p>ERC20을 준수한 토큰 컨트랙트는 최소한 다음 Function &amp; Events를 제공해야 한다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 필수 Functions</span>

<span class="kd">function</span> <span class="nf">totalSupply</span><span class="p">()</span>
   <span class="c1">// 현재 존재하는 이 토큰의 전체 개수를 리턴한다. (ERC20 토큰의 공급량은 고정 or 가변)</span>
<span class="kd">function</span> <span class="nf">balanceOf</span><span class="p">(</span><span class="nx">account</span><span class="p">)</span>
   <span class="c1">// 해당 주소의 토큰 잔액을 리턴한다.</span>
<span class="kd">function</span> <span class="nf">transfer</span><span class="p">(</span><span class="nx">to</span><span class="p">,</span> <span class="nx">amount</span><span class="p">)</span>
   <span class="c1">// 해당 주소로 주어진 금액의 토큰을 전송한다. 그리고 성공 여부를 bool로 리턴한다.</span>
<span class="kd">function</span> <span class="nf">approve</span><span class="p">(</span><span class="nx">spender</span><span class="p">,</span> <span class="nx">amount</span><span class="p">)</span>
   <span class="c1">// 해당 주소로 주어진 최대 금액까지 여러 번 송금할 수 있도록 승인한다. 그리고 성공 여부를 bool로 리턴한다.</span>
<span class="kd">function</span> <span class="nf">transferFrom</span><span class="p">(</span><span class="k">from</span><span class="p">,</span> <span class="nx">to</span><span class="p">,</span> <span class="nx">amount</span><span class="p">)</span>
   <span class="c1">// 보내는 주소에서 받는 주소로 주어진 금액의 토큰을 전송한다. 보내는 주소로부터 approve를 받은 상태에서 최대 금액까지 가능하다. 그리고 성공 여부를 bool로 리턴한다.</span>
<span class="kd">function</span> <span class="nf">allowance</span><span class="p">(</span><span class="nx">owner</span><span class="p">,</span> <span class="nx">spender</span><span class="p">)</span>
   <span class="c1">// approve로 승인된 주소에서 송금할 수 있는 잔액을 리턴한다.</span>

<span class="c1">// 필수 Events</span>

<span class="nx">event</span> <span class="nc">Transfer</span><span class="p">(</span><span class="k">from</span><span class="p">,</span> <span class="nx">to</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span>
   <span class="c1">// transfer나 transferFrom이 성공되면 Transfer 이벤트가 트리거된다.</span>
<span class="nx">event</span> <span class="nc">Approval</span><span class="p">(</span><span class="nx">owner</span><span class="p">,</span> <span class="nx">spender</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span>
   <span class="c1">// approve가 성공되면 Approval 이벤트가 트리거된다.</span>

<span class="c1">// 선택 Functions</span>

<span class="kd">function</span> <span class="nf">name</span><span class="p">()</span>
   <span class="c1">// 토큰의 이름을 리턴한다.</span>
<span class="kd">function</span> <span class="nf">symbol</span><span class="p">()</span>
   <span class="c1">// 토큰의 심볼을 리턴한다.</span>
<span class="kd">function</span> <span class="nf">decimals</span><span class="p">()</span>
   <span class="c1">// 토큰을 나눌 수 있는 소수 자릿수를 리턴한다.</span>
</code></pre></div></div>
<blockquote>
  <p>작성자: Joshua</p>
</blockquote>

<p>ERC20 컨트랙트는 2개의 데이터 구조를 포함하고 있다.</p>
<ul>
  <li>(1) 잔고 추적하기 (<strong>balance</strong>)</li>
  <li>(2) 허용량을 추적하기 (<strong>approve</strong>)</li>
</ul>

<p><strong>approve → transferFrom</strong>  구조는 거래소에서 사용할 수 있다.</p>
<ul>
  <li>예를 들어, 회사가 ICO를 위해 토큰을 판매하는 경우, 크라우드세일 컨트랙트를 approve할 수 있다.</li>
</ul>

<p><img src="/assets/2023-12-05-mastering-ethereum/josh-ico-1.webp" alt="" /></p>
<blockquote>
  <p>작성자: Joshua</p>
</blockquote>

<p><img src="/assets/2023-12-05-mastering-ethereum/josh-ico-2.webp" alt="" /></p>
<blockquote>
  <p>작성자: Joshua</p>
</blockquote>

<p>일반적으로 컨트랙트의  <code class="language-plaintext highlighter-rouge">transfer(from, to, 100 JOSH)</code>를 실행할 때, 받는 주소를 컨트랙트 자체의 주소로 입력할 경우 토큰이 영원히 갇혀 손실된다.</p>
<ul>
  <li>이를 해결할 수 있는 유일한 방법은 해당 컨트랙트가  <strong>approve &amp; transferFrom</strong>  워크플로 함수를 통해 보내는 주소가 transferFrom을 사용하여 반환하도록 하는 코드도 내장된 상태가 되어야 하는 것이다. 물론, 이는 보내는 주소의 지갑 앱이 transferFrom 함수 호출 기능을 보유해야 한다.</li>
</ul>

<p>토큰 전송에서 트랜잭션이 토큰 수신자에게 실제로 보내는 것이 아니다. 대신, 받는 사람의 주소가 토큰 컨트랙트 자체의 맵에 추가된다.</p>

<p><strong>상태 변경</strong></p>
<ul>
  <li>ETH를 주소로 보내는 트랜잭션: 주소의 상태를 변경</li>
  <li>토큰을 주소로 전송하는 트랜잭션: 토큰 컨트랙트의 상태를 변경 (주소의 상태는 변경하지 않는다.)</li>
</ul>

<p><strong>ERC20 토큰의 문제점</strong></p>
<ul>
  <li>ERC20 토큰을 지원하는 지갑조차도 사용자가 토큰 컨트랙트를 명시적으로 추가하지 않는 한 토큰 잔액을 인식하지 못한다.</li>
</ul>

<p><img src="/assets/2023-12-05-mastering-ethereum/metamask.webp" alt="" /></p>
<blockquote>
  <p>메타마스크가 토큰 컨트랙트를 매핑하지 않은 상태에서는 최종 사용자가 직접 Import Tokens를 통해 추가해줘야 한다. (출처: Metamask Chrome Extension)</p>
</blockquote>

<ul>
  <li>거래소를 통해 ETH를 ERC20 토큰으로 교환할 때는 송금 대상과 수수료 대상이 모두 ETH였는데, ERC20 토큰을 ETH로 교환할 때는 송금 대상과 수수료 대상이 서로 달라진다. 이는 UX 측면에서 불편함이 해소되어야 하는 부분이다.</li>
</ul>

<h2 id="erc223-tokens">ERC223 Tokens</h2>

<p>ERC223은 tokenFallback 함수를 통해 목적지 주소를 컨트랙트로 설정하여 잘못 송금하는 경우의 문제를 해결하고자 제안된 표준이다.</p>

<h2 id="erc721-tokens">ERC721 Tokens</h2>

<p>ERC721은 증서(deed)로도 알려진 대체할 수 없는(non-fungible) 토큰에 대한 표준을 위한 것이다.</p>

<p>ERC721 표준은 증서에 의해 그 소유권이 고유하게 추적될 수 있는 한, 그 대상의 종류에 대해 제한이나 규정을 두지 않으며, 이러한 추적은 256bit 식별자에 의해 이루어진다.</p>

<p><strong>ERC20 vs. ERC721 비교</strong></p>

<table>
  <thead>
    <tr>
      <th><strong>구분</strong></th>
      <th><strong>ERC20</strong></th>
      <th><strong>ERC721</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>기본 Mapping Key</strong></td>
      <td>address</td>
      <td>증서(deed) ID</td>
    </tr>
    <tr>
      <td><strong>추적 대상</strong></td>
      <td>각 address의 잔액</td>
      <td>증서 ID와 owner’s address</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>작성자: Joshua</p>
</blockquote>

<p><strong>ERC721 컨트랙트의 Interface 필수 사양 &amp; 선택 사양</strong></p>

<ul>
  <li>필수 사양 = ERC165</li>
</ul>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 필수 Functions (ERC165)</span>
<span class="nf">balanceOf</span><span class="p">(</span><span class="nx">owner</span><span class="p">)</span>
   <span class="c1">// 특정 주소가 소유한 증서의 개수를 리턴한다.</span>
<span class="nf">ownerOf</span><span class="p">(</span><span class="nx">tokenId</span><span class="p">)</span>
   <span class="c1">// 특정 증서의 소유자 주소를 리턴한다.</span>
<span class="nf">transfer</span><span class="p">(</span><span class="nx">to</span><span class="p">,</span> <span class="nx">tokenId</span><span class="p">)</span>
   <span class="c1">// 특정 증서를 해당 주소로 전송한다. payable 상태가 리턴된다.</span>
<span class="nf">approve</span><span class="p">(</span><span class="nx">to</span><span class="p">,</span> <span class="nx">tokenId</span><span class="p">)</span>
   <span class="c1">// 해당 주소가 특정 증서를 사용할 수 있도록 승인한다. payable 상태가 리턴된다.</span>
<span class="nf">setApprovalForAll</span><span class="p">(</span><span class="nx">operator</span><span class="p">,</span> <span class="nx">approved</span><span class="p">)</span>
   <span class="c1">//  해당 주소로 모든 증서를 사용할 수 있도록 승인한다. payable 상태가 리턴된다.</span>
<span class="nf">transferFrom</span><span class="p">(</span><span class="k">from</span><span class="p">,</span> <span class="nx">to</span><span class="p">,</span> <span class="nx">tokenId</span><span class="p">)</span>
   <span class="c1">// 보내는 주소에서 받는 주소로 특정 증서를 전송한다. 보내는 주소로부터 approve를 받은 경우에만 가능하다. 그리고 payable 상태가 리턴된다.</span>
<span class="nf">supportsInterface</span><span class="p">(</span><span class="nx">interfaceId</span><span class="p">)</span>
   <span class="c1">// Interface 검증을 할 수 있다. 해당 interface 지원 여부를 bool로 리턴한다.</span>

<span class="c1">// 필수 Events (ERC165)</span>
<span class="nx">event</span> <span class="nc">Transfer</span><span class="p">(</span><span class="k">from</span><span class="p">,</span> <span class="nx">to</span><span class="p">,</span> <span class="nx">tokenId</span><span class="p">)</span>
   <span class="c1">// transfer나 transferFrom이 payable 되면 Transfer 이벤트가 트리거된다.</span>
<span class="nx">event</span> <span class="nc">Approval</span><span class="p">(</span><span class="nx">owner</span><span class="p">,</span> <span class="nx">approved</span><span class="p">,</span> <span class="nx">tokenId</span><span class="p">)</span>
   <span class="c1">// approve가 payable 되면 Approval 이벤트가 트리거된다.</span>
<span class="nx">event</span> <span class="nc">ApprovalForAll</span><span class="p">(</span><span class="nx">owner</span><span class="p">,</span> <span class="nx">operator</span><span class="p">,</span> <span class="nx">approved</span><span class="p">)</span>
   <span class="c1">// setApprovalForAll이 payable 되면 ApprovalForAll 이벤트가 트리거된다.</span>
</code></pre></div></div>

<blockquote>
  <p>작성자: Joshua</p>
</blockquote>

<ul>
  <li>선택 사양</li>
</ul>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 선택 Functions (메타데이터) (ERC721)</span>
<span class="kd">function</span> <span class="nf">name</span><span class="p">()</span>
   <span class="c1">// 본 컨트랙트의 이름을 리턴한다.</span>
<span class="kd">function</span> <span class="nf">symbol</span><span class="p">()</span>
   <span class="c1">// 본 컨트랙트의 심볼을 리턴한다.</span>
<span class="kd">function</span> <span class="nf">tokenUri</span><span class="p">(</span><span class="nx">tokenId</span><span class="p">)</span>
   <span class="c1">// 해당 증서에 연결된 메타데이터 주소인 URI를 리턴한다.</span>

<span class="c1">// 선택 Functions (증서 및 소유자 열거) (ERC721)</span>
<span class="kd">function</span> <span class="nf">totalSupply</span><span class="p">()</span>
   <span class="c1">// 현재 존재하는 증서의 전체 개수를 리턴한다.</span>
<span class="kd">function</span> <span class="nf">tokenByIndex</span><span class="p">(</span><span class="nx">index</span><span class="p">)</span>
   <span class="c1">// 해당 index에 위치하는 증서의 ID를 리턴한다.</span>
<span class="kd">function</span> <span class="nf">countOfOwners</span><span class="p">()</span>
   <span class="c1">// 현재 존재하는 소유자 주소의 전체 개수를 리턴한다.</span>
<span class="kd">function</span> <span class="nf">ownerByIndex</span><span class="p">(</span><span class="nx">index</span><span class="p">)</span>
   <span class="c1">// 해당 index에 위치하는 증서의 소유자 주소를 리턴한다.</span>
<span class="kd">function</span> <span class="nf">tokenOfOwnerByIndex</span><span class="p">(</span><span class="nx">owner</span><span class="p">,</span> <span class="nx">index</span><span class="p">)</span>
   <span class="c1">// 해당 index에 위치하는 증서와 소유자 주소를 통해 증서의 ID를 리턴한다.</span>
</code></pre></div></div>

<blockquote>
  <p>작성자: Joshua</p>
</blockquote>

<p><strong>토큰 표준의 목적</strong></p>
<ul>
  <li>컨트랙트 간의 상호운용성(Interoperability)을 장려하는 것이다.</li>
  <li>즉, ERC20 표준을 따르는 컨트랙트를 배포하면 기존 지갑 사용자는 지갑을 업그레이드하는 노력을 들이지 않고도 토큰을 원활하게 전송할 수 있다.</li>
</ul>

<h1 id="12-chapter-11-oracles">12. [Chapter 11] Oracles</h1>

<p>합의를 유지하기 위해서 EVM 실행은 완전히 결정론적이고, 이더리움 상태와 서명된 트랜잭션의 공유 컨텍스트에 기반을 두고 있어야 한다.</p>
<ul>
  <li>(1) EVM 및 스마크 컨트랙트는 임의성을 위한 고유한 소스가 없다.</li>
  <li>(2) 외부 데이터는 트랜잭션의 데이터 payload로서만 유입될 수 있다.</li>
</ul>

<p>예를 들면, EVM이 스마트 컨트랙트에 Random Function의 사용을 금지하는 맥락은 대강 그림과 같다.</p>

<p><img src="/assets/2023-12-05-mastering-ethereum/random-function.webp" alt="" /></p>
<blockquote>
  <p>작성자: Joshua</p>
</blockquote>

<p>오라클은 이상적으로 스마트 컨트랙트를 위해 이더리움 플랫폼으로 축구 경기의 결과나 금 가격 혹은 순수 난수와 같은 외부 (Off-chain) 정보를 가지고 오는 데 Trustless 방법을 제공한다.</p>

<p><strong>오라클의 핵심 디자인</strong></p>
<ul>
  <li>(1) Off-chain 소스에서 데이터를 수집하고,</li>
  <li>(2) 이 데이터를 Signed Msg로 On-chain에 전송하고,</li>
  <li>(3) 이를 컨트랙트의 Storage에 저장하여 사용한다.</li>
</ul>

<h2 id="오라클-설정하는-세-가지-방법"><strong>오라클 설정하는 세 가지 방법</strong></h2>

<p><strong>(1) 즉시 읽기</strong></p>
<ul>
  <li>즉시 읽기 방식의 오라클은 ‘<a href="http://ethereumbook.info/">http://ethereumbook.info</a>의 주소는 무엇인가?’ 또는 ‘이 사람은 18세 이상인가?’와 같은 즉각적인 결정이 필요한 데이터만을 제공한다.</li>
  <li>이런 종류의 오라클은 컨트랙트 Storage에 데이터를 저장하고, 다른 컨트랙트는 오라클 컨트랙트에 요청을 해서 이러한 데이터를 검색할 수 있다. 그리고 이 데이터는 업데이트될 수도 있다.</li>
  <li>오라클 Storage에 있는 데이터는 dApp에 의해 직접 조회될 수 있기 때문에 번거로운 절차나 트랜잭션을 처리하는 Gas Fee가 필요하지 않다.</li>
  <li>이 저장된 데이터는 효율성이나 프라이버시 때문에 Raw Data가 아닌, 머클 트리에서 Hashing된 Root Hash를 저장하는 것으로 충분할 수 있다.</li>
</ul>

<p><strong>(2) 게시-구독</strong></p>
<ul>
  <li>게시-구독 방식의 오라클은 값의 업데이트가 빈번한 데이터를 효과적으로 브로드캐스트하는 역할로 제공한다.</li>
  <li>이 데이터는 온체인 컨트랙트에 의해 polling되거나 업데이트를 위한 Off-chain 데몬에 의해 모니터링된다.</li>
  <li>즉, 오라클이 새로운 데이터로 업데이트되면, 새로운 데이터를 쓸 수 있음을 구독자들에게 알린다.</li>
  <li>Polling이 컨트랙트로부터 수행되어야 하는 경우 상당한 Gas Fee가 발생할 수 있다.</li>
</ul>

<p><strong>(3) 요청-응답</strong></p>
<ul>
  <li>요청-응답 방식의 오라클은 컨트랙트에 저장하기에는 데이터가 너무 크고, 사용자는 그 중 일부의 데이터만 필요하는 경우에 사용된다.</li>
  <li>요청-응답 방식은 그림과 같이 여러 단계에 걸친 비동기 프로세스이다.</li>
</ul>

<pre><code class="language-plain"># 요청-응답 방식 오라클의 프로세스
   (1) 오라클 CA가 dApp으로부터 질의(query)를 받는다.
   (2) 오라클 CA는 해당 질의를 분석한다.
   (3) 오라클 CA는 dApp의 비용 지불 여부와 접근 권한 등을 확인한다.
   (4) 오라클 CA는 Off-chain 소스에서 관련 데이터를 검색한다.
   (5) 오라클 CA는 검색된 데이터가 포함된 TX에 Sign한다.
   (6) 오라클 CA는 Signed TX를 네트워크로 전파한다.
   (7) 알림 등 필요한 추가 TX를 스케줄링한다.
</code></pre>
<blockquote>
  <p>작성자: Joshua</p>
</blockquote>

<h2 id="계산-오라클">계산 오라클</h2>

<p>지금까지는 데이터를 요청하고 전달하는 맥락의 오라클이었다면, 계산 오라클은 On-chain에서 실행 불가능한 계산을 리턴하는 데 사용할 수 있다.</p>
<ul>
  <li>예를 들면, 계산 오라클을 통해 회귀 계산이나 머신러닝을 수행하여 채권 컨트랙트의 수익률을 추정할 수 있다.</li>
  <li>중앙화된 데이터 또는 계산 오라클은 이더리움 네트워크에서는 단일 실패 지점(SPOF)이 된다.</li>
</ul>

<p><strong>계산 오라클 문제의 개선 방법: 탈중앙화 오라클</strong></p>
<ul>
  <li>탈중앙화 오라클은 데이터 가용성을 보장하고 On-chain 데이터 Aggregation 시스템을 갖춘 개별 데이터 제공자의 네트워크를 만드는 수단이다.</li>
  <li><strong>체인링크</strong>: 평판 CA, 오더매칭 CA, Aggregation CA라는 3가지 핵심 컨트랙트와 데이터 공급자의 Off-chain 레지스트리로 구성된 탈중앙화 오라클 네트워크이다.</li>
  <li><strong>Aggregation CA</strong>: 여러 오라클로부터 응답을 수집하고, 최종 결과를 계산하여, 그 결과를 피드백해준다.</li>
  <li>Aggregation을 위한 함수를 공식화하는 것이 가장 어려운 문제인데, 값의 분포를 통한 penalizing, median 등 다양한 집계 방법들이 있다.</li>
</ul>

<h1 id="13-chapter-12-decentralized-applications-dapps">13. [Chapter 12] Decentralized Applications (dApps)</h1>

<p>dApp은 대부분 또는 완전히 탈중앙화된 애플리케이션이다. 션실적으로 이더리움 생태계에서 완전히 탈중앙화된 앱은 매우 드물다. 대부분 중앙화된 서비스와 서버를 사용하는 형태의 dApp이다.</p>

<p><strong>전형적인 중앙화된 아키텍처와 대비하여 dApp이 가진 장점</strong></p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">지속성</code></li>
  <li><code class="language-plaintext highlighter-rouge">투명성</code></li>
  <li><code class="language-plaintext highlighter-rouge">검열저항성</code></li>
</ul>

<h2 id="애플리케이션이-탈중앙화될-수-있는-측면들">애플리케이션이 탈중앙화될 수 있는 측면들</h2>

<p><strong>(1) 백엔드: 스마트 컨트랙트</strong></p>
<ul>
  <li>앱의 백엔드 혹은 서버 구성요소를 스마트 컨트랙트로 대체할 수 있다. 물론, 컨트랙트의 실행 비용이 매우 비싸기 때문에 최소한의 부분만 대체하는 것이 좋다.</li>
  <li>컨트랙트가 배포된 후 코드를 변경할 수 없다.  <strong>SELFDESTRUCT</strong>  연산코드가 프로그래밍된 경우완전히 제거하는 것 외에는 코드 자체를 수정할 수 없다.</li>
</ul>

<p><strong>(2) 프론트엔드: 웹 UI</strong></p>
<ul>
  <li>dApp 클라이언트 쪽 인터페이스는 HTML/CSS/JS를 사용할 수 있다. 메시지 서명, TX 전송, 키 관리 같은 이더리움과의 상호작용은 Metamask 같은 익스텐션을 통해 웹 브라우저에서 수행된다.</li>
</ul>

<p><strong>(3) 데이터 스토리지</strong></p>
<ul>
  <li>높은 Gas Price와 낮은 Block Gas Limit 때문에 컨트랙트는 많은 양의 데이터를 저장하거나 처리하는 데 적합하지 않다.</li>
  <li>따라서 대부분의 dApp은 Off-chain 데이터 스토리지 서비스를 사용하는데, 사이즈가 큰 데이터들을 이더리움 체인으로부터 데이터 스토리지 플랫폼으로 옮겨 저장한다.</li>
  <li>클라우드 처럼 중앙화된 방식, 혹은 IPFS나 이더리움의 Swarm 같은 탈중앙화된 방식</li>
  <li><strong>IPFS(Inter-planetary File System)</strong>: 저장된 객체를 P2P 네트워크 내 Peer들에게 배포하는 content-addressable 스토리지 시스템이다.</li>
  <li>content-addressable이란, 각 파일이 hashing되고, 그 hash를 통해 해당 파일을 식별할 수 있음을 의미한다. 즉, hash로 요청하여 모든 IPFS 노드에서 파일을 검색할 수 있다.</li>
  <li><strong>Swarm</strong>: IPFS와 유사한 content-addressable P2P 스토리지 시스템이다.</li>
</ul>

<p><strong>(4) 메시지 통신</strong></p>
<ul>
  <li>앱 간, 앱 내 인스터스 간, 혹은 앱 사용자 간의 메시지를 교환하기 위해 여러 가지 탈중앙화 프로토콜을 사용할 수 있다.</li>
  <li>대표적으로 Go-ethereum의 일부 도구인 Whisper</li>
</ul>

<p><strong>(5) 네임 레졸루션 (Name Resolution)</strong></p>
<ul>
  <li>ENS(Ethereum Name Service)</li>
</ul>

<p><img src="/assets/2023-12-05-mastering-ethereum/ens.webp" alt="" /></p>
<blockquote>
  <p><a href="https://docs.ens.domains/">Source</a></p>
</blockquote>

<p><strong>경매 dApp의 아키텍처 운용 사례</strong></p>

<p><img src="/assets/2023-12-05-mastering-ethereum/auction-dapp.webp" alt="" /></p>
<blockquote>
  <p>작성자: Joshua</p>
</blockquote>

<p><strong>경매 dApp의 주요 구성요소</strong></p>
<ul>
  <li>ERC721 컨트랙트</li>
  <li>경매 컨트랙트</li>
  <li>Vue JS 프레임워크를 사용하는 Web Frontend</li>
  <li>이더리움에 연결하는 web3.js 라이브러리</li>
  <li>데이터 스토리지인 Swarm 클라이언트</li>
  <li>경매 대화방을 위한 Whisper 클라이언트</li>
</ul>

<p><strong>경매 dApp을 더 탈중앙화하기 위한 방법은 크게 두 가지</strong></p>
<ul>
  <li>모든 애플리케이션 소스코드를 Swarm이나 IPFS에 저장한다.</li>
  <li>ENS를 사용하여 Name을 참조하여 dApp에 접근한다.</li>
</ul>

<p><strong>dApp 거버넌스는 크게 두 가지 옵션 중 하나를 선택하여 배포할 수 있다.</strong></p>
<ul>
  <li>dApp의 컨트랙트에 대한 특정 통제권을 지닌 EOA가 있는 경우</li>
  <li>dApp의 컨트랙트에 대한 특정 통제권을 지닌 EOA가 없는 경우</li>
</ul>

<p>dApp을 구축할 때 컨트랙트를 완전히 독립적으로 만들고 출시한 후에 제어할 권한을 없게 만들든지 또는 특권 계정을 만들고 위험에 노출될 위험을 감수해야 하는지를 결정해야 한다.</p>
<ul>
  <li>하지만 장기적으로 진정한 dApp은 특권 계정을 위한 특수 접근 권한을 허용하지 말아야 한다. 왜냐하면 그것은 탈중앙화된 것이 아니기 때문이다.</li>
</ul>

<h2 id="ens-ethereum-name-service">ENS (Ethereum Name Service)</h2>

<p>전통적인 인터넷에서 DNS(Domain Name System)는 브라우저에서 사람이 읽을 수 있는 이름을 사용할 수 있게 해준다. 이더리움 블록체인에서는 ENS(Ethereum Name Service)가 이와 같은 문제를 탈중앙화된 방식으로 풀어준다.</p>
<ul>
  <li>이더리움 재단의 기부 주소  <strong>0xfB6916…d359</strong>: ENS를 지원하는 지갑에서는 간단하게  <strong>ethereum.eth</strong></li>
  <li>Name의 등록, 관리, 그리고 경매를 위한 여러 dApp이 ENS 기능을 지원</li>
</ul>

<p><strong>ENS의 개선 제안 3가지</strong></p>
<ul>
  <li>ENS의 기본 기능 정의한 EIP-137</li>
  <li><code class="language-plaintext highlighter-rouge">.eth</code> 루트의 경매 시스템을 설명한 EIP-162</li>
  <li>주소의 역 등록을 지정한 EIP-181</li>
</ul>

<p><strong>ENS는 다음 그림과 같이 ‘샌드위치’ 디자인 철학</strong></p>

<p><img src="/assets/2023-12-05-mastering-ethereum/ens-sandwich.webp" alt="" /></p>
<blockquote>
  <p>작성자: Joshua</p>
</blockquote>

<p><strong>맨 아래 계층 (EIP-137)</strong></p>

<p><img src="/assets/2023-12-05-mastering-ethereum/eip-137.webp" alt="" /></p>
<blockquote>
  <p>작성자: Joshua</p>
</blockquote>

<p>Namehash 알고리즘</p>
<ul>
  <li>어떤 이름이라도 그 이름을 식별하는 해시로 변환할 수 있는 Recursive 알고리즘</li>
  <li>즉, Namehash는 재귀적으로 이름의 각 구성요소를 해시하여 유효한 입력 도메인에 대한 고유한 고정 길이 문자열(또는 node)을 생성한다.</li>
  <li>재귀성이 중요한 이유는 각 name이 서브도메인을 무한히 가질 수 있는데, 이를 반복적으로 재계산하려면 Gas Fee가 많이 소요되므로, 루트 도메인의 node 값을 미리 컨트랙트에 삽입하여 계산 효율성을 갖추기 위한 것이다.</li>
  <li>위 그림에서 node는 Namehash 알고리즘에 의해 변환된 hash를 의미한다.</li>
</ul>

<p>resolver 컨트랙트</p>
<ul>
  <li>앱과 관련된 Swarm 주소, 앱에 지불할 주소나 앱의 Hash와 같은 이름에 대한 질문에 답변할 수 있는 사용자 생성 컨트랙트이다.</li>
</ul>

<p><strong>중간 계층 (EIP-162)</strong></p>

<p><img src="/assets/2023-12-05-mastering-ethereum/eip-162.webp" alt="" /></p>
<blockquote>
  <p>작성자: Joshua</p>
</blockquote>

<p><strong>최상위 계층 (EIP-181)</strong></p>

<p><img src="/assets/2023-12-05-mastering-ethereum/eip-181.webp" alt="" /></p>
<blockquote>
  <p>작성자: Joshua</p>
</blockquote>

<p><strong>ENS에서 이름을 확인하는 과정</strong></p>
<ul>
  <li>(1) 해석하고 싶은 이름을 통해 ENS Registry가 호출된다.</li>
  <li>(2) 레코드가 존재하면 ENS Registry는 resolver의 주소를 리턴한다.</li>
  <li>(3) 해당 주소의 resolver는 요청된 자원에 적절한 method를 통해 호출된다.</li>
  <li>(4) resolver는 원하는 결과를 리턴한다.</li>
</ul>

<p>이 프로세스는 resolver의 기능을 naming system 자체와 분리하여 더 많은 유연성을 얻을 수 있다는 이점이 있다. 즉, ENS의 향후 확장하기 용이한 것이다.</p>

<p><strong>경매 dApp을 완전히 탈중앙화된 상태일 때 아키텍처 사례</strong></p>

<p><img src="/assets/2023-12-05-mastering-ethereum/dapp-browser.webp" alt="" /></p>
<blockquote>
  <p>작성자: Joshua</p>
</blockquote>

<h1 id="14-chapter-13-ethereum-virtual-machine-evm">14. [Chapter 13] Ethereum Virtual Machine (EVM)</h1>

<p>EVM은 마이크로소프트의 .NET 프레임워크 VM이나 Java와 같은 Bytecode 컴파일된 프로그래밍 언어의 Interpreter와 비슷한 역할을 하는 계산 엔진이다.</p>

<p>EVM은 스마트 컨트랙트 배포 및 실행을 처리하는 이더리움의 일부다.</p>
<ul>
  <li>EOA to EOA로의 간단한 값을 전송하는 TX는 사실상 EVM이 필요 없지만, 그 외 모든 것은 EVM에 의한 상태 업데이트를 수반한다.</li>
</ul>

<p>EVM은 유사 튜링 완전 상태 머신(quasi-Turing-complete state machine)이다.</p>
<ul>
  <li>이것은 스마트 컨트랙트 실행에 사용할 수 있는 가스량에 따라 모든 실행 프로세스가 유한 개의 계산 단계로 제한된다는 것을 의미한다.</li>
</ul>

<p>EVM은 메모리 내의 모든 값을 스택에 저장하는 스택 기반 아키텍처다.</p>
<ul>
  <li>256bit의 단어 크기로 동작하며, 주소 지정이 가능한 여러 개의 데이터 구성요소를 가지고 있다.</li>
</ul>

<p><strong>EVM의 구성요소</strong></p>

<p><img src="/assets/2023-12-05-mastering-ethereum/evm-architecture.webp" alt="" /></p>
<blockquote>
  <p><a href="https://takenobu-hs.github.io/downloads/ethereum_evm_illustrated.pdf">Source</a></p>
</blockquote>

<ul>
  <li>(1) 실행할 컨트랙트의 bytecode가 저장되는 불변 프로그램 코드 ROM</li>
  <li>(2) 모든 위치가 0으로 초기화된 휘발성 메모리</li>
  <li>(3) 이더리움 상태의 일부인 영구 스토리지 (0으로 초기화됨)</li>
</ul>

<p>EVM은 실행 순서가 외부에서 구성되기 때문에 스케줄링 기능이 없다.</p>
<ul>
  <li>즉, 이더리움 클라이언트가 검증된 블록의 트랜잭션을 통해 어떤 스마트 컨트랙트가 어떤 순서로 실행되어야 하는지를 결정한다.</li>
  <li>이러한 의미에서 이더리움 월드 컴퓨터는 JS처럼 단일 스레드다.</li>
</ul>

<p><strong>EVM 아키텍처와 실행 컨텍스트</strong></p>

<p><img src="/assets/2023-12-05-mastering-ethereum/evm-architecture-context.webp" alt="" /></p>
<blockquote>
  <p>작성자: Joshua</p>
</blockquote>

<p>EVM은 일반적인 Bytecode 연산 작업 외에도 계정 정보(address, balance 등) 및 블록 정보(block number, current gas price 등)에 접근할 수도 있다.</p>

<p>EVM의 작업은 스마트 컨트랙트 코드의 실행 결과로 유효한 상태 변화를 계산하여 이더리움 상태를 업데이트 하는 것이다.</p>
<ul>
  <li>이러한 측면에서 이더리움을  <strong>transaction-based state machine</strong>으로 설명</li>
  <li>외부 주체(즉, EOA 및 Miner)가 TX 생성, 수락 및 주문을 통해 상태 변화를 시작</li>
</ul>

<p>이더리움 상태의 가장 상위 레벨에는  <strong>World State</strong>가 있다.</p>
<ul>
  <li>World State는 이더리움 주소(160bit)를 Account에 매핑한 것</li>
  <li>각 이더리움 주소는 ETH balance, nonce, account storage, programming code를 의미</li>
</ul>

<p><strong>이더리움 주소의 Nonce</strong></p>
<ul>
  <li>EOA일 경우: 성공적으로 전송한 TX의 수</li>
  <li>CA일 경우: 생성된 컨트랙트의 수</li>
</ul>

<p><strong>EOA에는 storage가 비어 있고, programming code가 없다.</strong></p>

<p><img src="/assets/2023-12-05-mastering-ethereum/eoa-ca.webp" alt="" /></p>
<blockquote>
  <p><a href="https://takenobu-hs.github.io/downloads/ethereum_evm_illustrated.pdf">Source</a></p>
</blockquote>

<p><strong>TX가 스마트 컨트랙트 코드를 실행하면:</strong></p>
<ul>
  <li>EVM은 생성 중인 현재 블록 및 처리 중인 특정 TX와 관련하여 필요한 모든 정보로 instance화 된다.</li>
  <li>TX가 컨트랙트 코드를 실행하다가 어떤 시점에서 가스 부족(Out of Gas) 예외가 발생하면 실행이 즉시 중단되고 TX가 중단된다.</li>
  <li>이더리움 상태는 변경되지 않으며, 단지 TX 발신자의 nonce가 증가되고 중단시점까지 코드를 실행하는 데 사용된 가스 만큼 ETH 잔액이 줄어든다.</li>
</ul>

<p><strong>정지 문제 (halting problem)</strong></p>
<ul>
  <li>어떠한 스케줄러 없이 단일 스레드 머신처럼 동작하는 이더리움에게 매우 중요한 문제다.</li>
  <li>그러나 가스를 사용하면 해결 방법이 생긴다.</li>
  <li>미리 지정된 최대 계산량을 수행한 후에 실행이 종료되지 않는다면 프로그램 실행은 EVM에 의해 중단된다.</li>
  <li>이렇게 하면 EVM이 유사(quasi) 튜링 완전 머신이 된다.</li>
  <li>즉, 프로그램이 특정 계산량 내에서 종료되는 경우에만 프로그램을 실행할 수 있다.</li>
</ul>

<p><strong>가스 (Gas)</strong></p>
<ul>
  <li>이러디움에서는 Block Gas Limit까지 프로그램을 실행할 수 있는데, 고정되어 있지 않기 대문에 시간이 지남에 따라 Limit을 늘리는 것에 동의할 수도 있다.</li>
  <li>가스는 이더리움 블록체인에서 작업을 수행하는 데 필요한 계산 및 스토리지 자원을 측정하는 이더리움의 단위다.</li>
  <li>비트코인은 KB 단위의 TX 크기만 고려하여 TX Fee를 측정하지만, 이더리움은 TX 및 컨트랙트 코드 실행에 의해 수행되는 모든 계산 단계를 고려한다.</li>
</ul>

<p><strong>가스의 역할</strong></p>
<ul>
  <li>(1) 이더리움의 가격 방어 수단 역할</li>
  <li>(2) 채굴자에 대한 보상 버퍼 역할</li>
  <li>(3) DoS 공격에 대한 방어 수단 역할 (따라서 공격자가 스팸 TX를 보내지 못하게 한다.)</li>
</ul>

<p><strong>가스 계산</strong></p>

<pre><code class="language-plain">   채굴 비용 = Gas Used * Gas Price
   잔여 가스 = Gas Limit * Gas Used
   환불 ETH = 잔여 가스 * Gas Price
</code></pre>
<blockquote>
  <p>작성자: Joshua</p>
</blockquote>

<ul>
  <li>새로운 블록을 만들 때 이더리움 네트워크에 있는 채굴자들은 pending TX들 중에서 더 높은 Gas Price를 지불하려는 TX를 선택할 수 있다.</li>
  <li>따라서 더 높은 Gas Price를 제공하면 굴자에게 TX를 포함하고 더 빨리 확인하도록 유도할 것이다.</li>
</ul>

<p><strong>Negative Gas</strong></p>
<ul>
  <li>이더리움은 컨트랙트 실행 중에 사용된 Gas 중 일부를 환불함으로써 사용된 저장 변수 및 계정을 삭제하도록 권장한다.</li>
  <li>환불 메커니즘의 악용을 피하기 위해 최대 환불액은 사용된 총 가스량의 50%로 설정된다.</li>
</ul>

<pre><code class="language-plain">   1. 컨트랙트를 삭제(SELFDESTRUCT)하면 24,000 Gas의 환급 가치가 있다.
   2. 0이 아닌 값에서 0으로 저장 주소를 변경하면 15,000 Gas의 환급 가치가 있다.
</code></pre>
<blockquote>
  <p>작성자: Joshua</p>
</blockquote>

<p><strong>Block Gas Limit</strong></p>
<ul>
  <li>블록의 모든 TX에서 소비될 수 있는 가스의 최대량이며, 한 블록에 들어갈 수 있는 TX 건수를 제한함</li>
  <li>채굴자가 현재 Block Gas Limit을 초과하는 가스가 필요한 TX를 포함하려 한다면, 그 블록은 네트워크에 의해 거절됨</li>
  <li>대부분의 이더리움 클라이언트는 “tx exceeds block gas limit”의 경고를 통해 그러한 TX를 하지 못하게 할 것임</li>
  <li>Block Gas Limit은 네트워크의 채굴자들이 집합적으로 결정함</li>
  <li>이더리움 프로토콜에는 채굴자가 Gas Limit에 투표할 수 있는 메커니즘이 내장되어 있어 이후 블록에서 용량을 늘리거나 줄일 수 있음</li>
  <li>각 채굴자들은 +/- 어느 방향으로든 1/1,024 (0.0976%)의 비율로 Block Gas Limit을 조정하기 위해 투표할 수 있음</li>
</ul>

<p><img src="/assets/2023-12-05-mastering-ethereum/etherscan-average-gas-limit.webp" alt="" /></p>
<blockquote>
  <p><a href="https://etherscan.io/chart/gaslimit">Source</a></p>
</blockquote>

<h1 id="15-chapter-14-consensus">15. [Chapter 14] Consensus</h1>

<p><strong>합의 (Consensus)</strong></p>
<ul>
  <li>분산 시스템에서 각기 다른 참여자가 한 시스템의 전 체 상태에 모두 동의하여 동기화하기 위한 것</li>
  <li>신뢰할 수 있는 중재인이 없으면 다른 방법을 사용하여 불일치, 기만 또는 차이점을 해결해야 하는데, 합의 알고리즘은 보안 및 탈중앙화를 해결하는 데 사용되는 것</li>
</ul>

<p><strong>비트코인의 PoW 합의 알고리즘</strong></p>
<ul>
  <li>가능한 한 많은 참가자로부터 탈중앙화된 시스템에 대한 통제권을 유지하며 블록체인을 보호하는 목적을 지니고 있다.</li>
</ul>

<p><strong>이더리움의 PoW 알고리즘</strong></p>
<ul>
  <li>Ethash라고 부르는데, 비트코인의 PoW 알고리즘과는 약간 다르다.</li>
  <li>방향성 비순환 그래프(Directed Acyclic Graph, DAG)로 알려진 대규모 데이터 세트의 생성 및 분석에 의존함</li>
  <li>이더리움 PoW에는  <strong>난이도 폭탄(Difficulty Bomb)</strong>이라는 핸디캡이 있으며, 이는 이더리움 채굴을 점차 어렵게 만들어서 PoW에서 PoS로의 전환을 강요하고 있다.</li>
  <li>이더리움의 계획된 PoS 알고리즘은  <strong>Casper</strong>라고 불리며, Casper를 도입하려는 시도는 여러 번 연기되어, 난이도폭탄을 완화하고 강제로 연기시키는 개입이 필요했다.</li>
</ul>

<p><strong>방향성 비순환 그래프 (Directed Acyclic Graph, DAG)</strong></p>
<ul>
  <li>DAG의 목적: 자주 접근하는 대규모 데이터 구조를 유지하는 데 필요한 Ethash PoW 알고리즘을 만드는 것</li>
  <li>이는 Ethash가 ASIC 저항성을 갖게 만들려는 것으로, 고속 GPU보다 훨씬 빠른 주문형 반도체(ASIC) 채굴 장비를 만들기가 더 어려워진다는 의미</li>
  <li>즉, 제조 공장 및 대규모 예산에 접근할 수 있는 사람들이 채굴 인프라를 지배하고 합의 알고리즘의 보안을 훼손할 수 있는 PoW 채굴의 중앙 집중화를 피하고자 한 것</li>
</ul>

<p><strong>PoS 알고리즘</strong></p>

<ol>
  <li>블록체인은 Validator 집합을 유지하며, 블록체인의 기본 암호화폐(ETH)를 보유한 사람은 ETH를 컨트랙트에 예치시키는 특별한 유형의 TX를 보냄으로써 Validator가 될 수 있다.</li>
  <li>Validator는 유효한 다음 블록에 대해 제안하고  투표하는 순서를 따르며, 각 Validator의 투표 중요도는 보증금(지분)의 크게 따라 다르다.</li>
  <li>특정 Validator가 보유한 블록이 대다수의 Validator에 의해 거부된다면 보증금을 잃을 위험이 있다.</li>
  <li>반대로, 대다수의 Validator가 수락한 모든 블록에 대해 누적된 보증금에 비례하여 작은 보상을 얻는다.</li>
  <li>따라서 PoS는 Validator에게 보상 및 처벌 제도에 따라 정직하게 행동하고 합의 규칙을 따르도록 한다.</li>
  <li>PoW에서는 처벌이 외적(전기 사용에 따른 자금 손실)이라면, PoS에서 처벌은 처벌이 내재적(지분 손실)인 것이다.</li>
</ol>

<hr />

<h2 id="published-by-joshua-kim"><em>Published by</em> Joshua Kim</h2>
<p><img src="/assets/profile/joshua-profile.png" alt="Joshua Kim" /></p>]]></content><author><name></name></author><category term="Blockchain" /><summary type="html"><![CDATA[개발적인 용어가 난무해서 당시에는 도저히 펼쳐 볼 엄두가 안 났지만, 이 업계에서 약 3년 가까이 구르다보니 어느 정도 잘 읽히게 되었다. 그래서 2023년 1월 1일 새해 목표 중 하나로 “마스터링 이더리움 완독하고 정리하기”를 세우게 되었다. 그리고 약 1개월 만에 다 읽게 되었다.]]></summary></entry><entry><title type="html">데이터 분석가의 SQL 최적화 일기: SELF JOIN을 피하는 방법</title><link href="http://localhost:4000/how-to-avoid-self-joins/" rel="alternate" type="text/html" title="데이터 분석가의 SQL 최적화 일기: SELF JOIN을 피하는 방법" /><published>2023-11-30T00:00:00+09:00</published><updated>2023-11-30T00:00:00+09:00</updated><id>http://localhost:4000/how-to-avoid-self-joins</id><content type="html" xml:base="http://localhost:4000/how-to-avoid-self-joins/"><![CDATA[<blockquote>
  <p>대고객 서빙을 위해 엄청나게 큰 사이즈의 소스 테이블로부터 최적화된 데이터 마트 설계 고민을 많이 하고 있는 만큼, 이번에는 SELF JOIN 사례를 중심으로 SQL 성능에 대한 이야기를 들려드리겠습니다.</p>
</blockquote>

<h3 id="contents">CONTENTS</h3>
<ol>
  <li>들어가는 글</li>
  <li>Python과 달리 거칠게 사고해야 하는 SQL</li>
  <li>SELF JOIN을 하면 연산량이 제곱으로 늘어난다.</li>
  <li>Subquery와 EXISTS 사용하기</li>
  <li>결론: 무조건적 우월성은 없다.</li>
</ol>

<hr />

<h3 id="disclaimer">DISCLAIMER</h3>

<p>본 자료는 작성자 본인의 견해일 뿐이며, 실제 데이터베이스의 환경에 따라 적합하지 않을 수 있습니다. 이미지 출처를 제외한 모든 쿼리문과 내용은 본인의 경험에 의해 작성되었습니다. 작성된 쿼리문은 샘플로 작성한 것이며, 본인의 과거 및 현재 재직 회사의 업무 현황과 무관합니다.</p>

<h1 id="1-들어가는-글">1. 들어가는 글</h1>

<p><img src="/assets/2023-11-30-how-to-avoid-self-joins/join-meme.webp" alt="" /></p>
<blockquote>
  <p><a href="https://miro.medium.com/v2/resize:fit:800/1*DTET9ngrx2Gzu6ZJk0G9BQ.jpeg">Source</a></p>
</blockquote>

<p>안녕하세요. 저는 친구들 얼굴을 보면 위와 같은 이상한 생각을 하는 데이터 분석가 Joshua라고 합니다.</p>

<p>저는 일반적인 B2C 기업에서 데이터 분석가로 근무하며, GA4, Amplitude, BigQuery, Redash 등을 활용하여 A/B 테스트, 지표 모니터링 등을 수행하며 회사의 등대 역할을 하며 지냈습니다. 다른 분들과 비슷한 역할을 수행했던 것이죠.</p>

<p>또한 GA4, Amplitude 등과 같은 B2B 데이터 분석 플랫폼 서비스를 만드는 경험도 살짝 했는데요. 그러다보니 저의 R&amp;R은 서비스 자체의 데이터 분석 업무 외에도, 고객들에게 데이터를 서빙하기 위한 데이터 마트 설계와 최적화 업무에 집중되기도 했습니다. 제 타이틀을 멋있게 가공하면 최근에 떠오르는 포지션인 Analytics Engineer, 반쪽 짜리 데이터 엔지니어, 아니면 대충 쿼리 머신 혹은 분지니어(?)인 것 같기도 합니다. 😅</p>

<p>대고객 서빙을 위해 엄청나게 큰 사이즈의 소스 테이블로부터 최적화된 데이터 마트 설계 고민을 많이 하고 있는 만큼, 이번에는 SELF JOIN 사례를 중심으로 SQL 성능에 대한 이야기를 들려드리겠습니다.
(SQL 전문가 분들이 많이 계시는 만큼, 제 글을 비판적으로 고찰해주시면 감사하겠습니다! 😄)</p>

<p>쿼리로 고통 받으며 눈동자에 비가 내렸던 경험 이야기, 시작합니다! (울지마~ 울지마~ 울지마~)</p>

<p><img src="/assets/2023-11-30-how-to-avoid-self-joins/crying-cat-meme.avif" alt="" /></p>
<blockquote>
  <p><a href="https://www.google.com/url?sa=i&amp;url=https%3A%2F%2Fwww.dailydot.com%2Fnews%2Fcat-crying-memes-explainer%2F&amp;psig=AOvVaw1JpDJ5k_6Tx93h2YT8in_Y&amp;ust=1702536707113000&amp;source=images&amp;cd=vfe&amp;opi=89978449&amp;ved=0CBMQjRxqFwoTCMC01dLpi4MDFQAAAAAdAAAAABAD">Source</a></p>
</blockquote>

<h1 id="2-python과-달리-거칠게-사고해야-하는-sql">2. Python과 달리 거칠게 사고해야 하는 SQL</h1>

<p>SQL을 통해 OLAP(Online Analytical Processing)에 해당하는 데이터 웨어하우스를 구축하다보면, 종종  <strong>SELF JOIN</strong>이 필요합니다. 가령, 소스 테이블의 복사본인 Staging Table을 Pivoting 해야 하거나, 칼럼 A와 칼럼 B 간의 관계 규칙을 찾아 Data Cleaning을 해야 하는 경우에 특히 발생하는 것 같았어요.</p>

<p>가령, Python의 Pandas Dataframe 환경에서는 메소드를 통해 너무나도 쉽게 Pivoting을 하거나, 반복문과 조건문을 통해 칼럼 사이의 관계 규칙을 고작 몇 줄 코드 만으로 Data Cleaning을 할 수 있을 것입니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pandas</span><span class="p">.</span><span class="n">DataFrame</span><span class="p">.</span><span class="n">pivot</span>
<span class="n">pandas</span><span class="p">.</span><span class="nf">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">value</span> <span class="k">if</span> <span class="n">condition</span> <span class="ow">is</span> <span class="n">true</span> <span class="k">if</span> <span class="n">x</span> <span class="n">condition</span> <span class="k">else</span> <span class="n">value</span> <span class="n">of</span> <span class="n">condition</span> <span class="ow">is</span> <span class="n">false</span><span class="p">)</span>
</code></pre></div></div>

<p>하지만 안타깝게도 SQL에서는 다소 거친 방법으로 쿼리문을 작성해야 하므로 좀 더 테이블 자체를 기반의 Logical Thinking을 하는 것이 중요합니다.</p>

<p>가령 다음 기본적인 사례와 같이, 국가 별로 MAU를 집계할 경우에 SQL은 훨씬 거칠게 표현합니다.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span>  
   <span class="n">DATE_TRUNC</span><span class="p">(</span><span class="s1">'MONTH'</span><span class="p">,</span> <span class="nb">datetime</span><span class="p">)</span> <span class="k">AS</span> <span class="n">yyyymm</span><span class="p">,</span>  
   <span class="n">country</span><span class="p">,</span>  
   <span class="k">COUNT</span><span class="p">(</span><span class="k">DISTINCT</span> <span class="n">user_id</span><span class="p">)</span> <span class="k">AS</span> <span class="n">mau</span>  
<span class="k">FROM</span>  
   <span class="n">source_events</span>  
<span class="k">GROUP</span> <span class="k">BY</span>  
   <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span>  
<span class="k">ORDER</span> <span class="k">BY</span>  
   <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span>  
<span class="p">;</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">source_events</span><span class="p">[</span><span class="sh">'</span><span class="s">yyyymm</span><span class="sh">'</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="p">.</span><span class="nf">to_datetime</span><span class="p">(</span><span class="n">source_events</span><span class="p">[</span><span class="sh">'</span><span class="s">datetime</span><span class="sh">'</span><span class="p">]).</span><span class="n">dt</span><span class="p">.</span><span class="nf">to_period</span><span class="p">(</span><span class="sh">'</span><span class="s">M</span><span class="sh">'</span><span class="p">)</span>  
<span class="n">result_df</span> <span class="o">=</span> <span class="n">source_events</span><span class="p">.</span><span class="nf">groupby</span><span class="p">([</span><span class="sh">'</span><span class="s">yyyymm</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">country</span><span class="sh">'</span><span class="p">]).</span><span class="nf">agg</span><span class="p">(</span><span class="n">mau</span><span class="o">=</span><span class="p">(</span><span class="sh">'</span><span class="s">user_id</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">nunique</span><span class="sh">'</span><span class="p">)).</span><span class="nf">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>  
<span class="n">result_df</span> <span class="o">=</span> <span class="n">result_df</span><span class="p">.</span><span class="nf">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="p">[</span><span class="sh">'</span><span class="s">yyyymm</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">country</span><span class="sh">'</span><span class="p">]).</span><span class="nf">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>  
<span class="nf">print</span><span class="p">(</span><span class="n">result_df</span><span class="p">)</span>
</code></pre></div></div>

<p>즉, 파이썬의  <code class="language-plaintext highlighter-rouge">to_period</code>,  <code class="language-plaintext highlighter-rouge">groupby</code>,  <code class="language-plaintext highlighter-rouge">nunique</code>  등과 같은 내장 메소드의 연산 원리를 이해하여 이를  <code class="language-plaintext highlighter-rouge">DATE_TRUNC</code>,  <code class="language-plaintext highlighter-rouge">COUNT(DISTINCT …)</code>,  <code class="language-plaintext highlighter-rouge">GROUP BY</code>  등의 SQL 함수와 Statement로 표현해야 하는 것이죠.</p>

<h1 id="3-self-join을-하면-연산량이-제곱으로-늘어난다">3. SELF JOIN을 하면 연산량이 제곱으로 늘어난다.</h1>

<p>먼저 다음과 같은 쿼리문 사례를 살펴보도록 하죠.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span>  
   <span class="n">MAIN</span><span class="p">.</span><span class="nb">datetime</span><span class="p">,</span>  
   <span class="n">MAIN</span><span class="p">.</span><span class="n">user_id</span><span class="p">,</span>  
   <span class="n">MAIN</span><span class="p">.</span><span class="n">session_id</span><span class="p">,</span>  
   <span class="n">MAIN</span><span class="p">.</span><span class="n">event_index</span><span class="p">,</span>  
   <span class="n">MAIN</span><span class="p">.</span><span class="n">event_param_index</span><span class="p">,</span>  
   <span class="n">MAIN</span><span class="p">.</span><span class="n">event_param_key</span><span class="p">,</span>  
   <span class="n">MAIN</span><span class="p">.</span><span class="n">event_param_value</span>  
<span class="k">FROM</span>  
   <span class="n">source_events</span> <span class="n">MAIN</span>  
<span class="k">LEFT</span> <span class="k">JOIN</span>  
   <span class="n">source_events</span> <span class="n">SUB</span>  
   <span class="k">ON</span> <span class="n">MAIN</span><span class="p">.</span><span class="n">user_id</span> <span class="o">=</span> <span class="n">SUB</span><span class="p">.</span><span class="n">user_id</span>  
      <span class="k">AND</span> <span class="n">MAIN</span><span class="p">.</span><span class="n">session_id</span> <span class="o">=</span> <span class="n">SUB</span><span class="p">.</span><span class="n">session_id</span>  
      <span class="k">AND</span> <span class="n">MAIN</span><span class="p">.</span><span class="n">event_index</span> <span class="o">=</span> <span class="n">SUB</span><span class="p">.</span><span class="n">event_index</span>  
<span class="k">WHERE</span>  
   <span class="n">MAIN</span><span class="p">.</span><span class="n">event_param_index</span> <span class="o">=</span> <span class="n">SUB</span><span class="p">.</span><span class="n">event_param_index</span> <span class="o">+</span> <span class="mi">0</span>  
   <span class="k">OR</span> <span class="n">MAIN</span><span class="p">.</span><span class="n">event_param_index</span> <span class="o">=</span> <span class="n">SUB</span><span class="p">.</span><span class="n">event_param_index</span> <span class="o">+</span> <span class="mi">1</span>  
   <span class="k">OR</span> <span class="n">MAIN</span><span class="p">.</span><span class="n">event_param_index</span> <span class="o">=</span> <span class="n">SUB</span><span class="p">.</span><span class="n">event_param_index</span> <span class="o">+</span> <span class="mi">2</span>  
   <span class="k">OR</span> <span class="n">MAIN</span><span class="p">.</span><span class="n">event_param_index</span> <span class="o">=</span> <span class="n">SUB</span><span class="p">.</span><span class="n">event_param_index</span> <span class="o">+</span> <span class="mi">3</span>
</code></pre></div></div>

<p>위 사례는 가령 이런 상황으로 이해하시면 될 것 같습니다. 사용자의 이벤트 로그 소스 테이블에서 각 이벤트의 파라미터 key-value가 unnested된 상태로 존재하거나, 혹은 특정 파라미터의 index를 기준으로 인접한 파라미터 정보들만 추출해야 하는 상황에서 위와 같은 쿼리문 작성이 필요할 것입니다.</p>

<p>SQL의 연산 과정은  <strong>FROM → XXX JOIN → WHERE → GROUP BY → SELECT → HAVING → ORDER BY</strong>  등의 순으로 진행되는데요. 위 쿼리문을 연산하는 과정에서 WHERE Statement에 진입하기 전에, 먼저 FROM과 LEFT JOIN을 통해 모든 Row를 메모리에 로드하게 됩니다.</p>

<p><img src="/assets/2023-11-30-how-to-avoid-self-joins/sql-processing.webp" alt="" /></p>
<blockquote>
  <p><a href="https://blog.kakaocdn.net/dn/ckOt66/btrjP1TVZsq/Ta9JdTTiEd9tddkKkFk2n1/img.png">Source</a></p>
</blockquote>

<p>가령,  <code class="language-plaintext highlighter-rouge">source_events</code>  테이블이 1,000,000개의 Row로 구성되어 있다면, 최대 1,000,000 * 1,000,000개의 Row가 메모리에 올라오게 되는 것이죠. 이는 쿼리 엔진의 메모리 및 트래픽 DevOps 환경이 중요한 경우 분명히 문제가 됩니다. 혹은 Usage Limit이 걸려 있을 경우에는 쿼리 실행이 몇 시간 동안 진행되다가 아침에 눈을 떠보면 트래픽 제한으로 인해 실행이 실패되었다는 매우 슬프고 참담한 상황에 마주하게 될 것입니다.</p>

<p><img src="/assets/2023-11-30-how-to-avoid-self-joins/crying-meme.webp" alt="" /></p>
<blockquote>
  <p><a href="https://res.heraldm.com/content/image/2021/07/16/20210716000671_0.jpg">Source</a></p>
</blockquote>

<p>그렇다면, 이런 상황에서 어떻게 쿼리를 최적화할 수 있을까요?</p>

<h1 id="4-subquery와-exists-사용하기">4. Subquery와 EXISTS 사용하기</h1>

<p>위에서 보셨던 쿼리문을 아래와 같이 수정해봤습니다.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span>  
   <span class="nb">datetime</span><span class="p">,</span>  
   <span class="n">user_id</span><span class="p">,</span>  
   <span class="n">session_id</span><span class="p">,</span>  
   <span class="n">event_index</span><span class="p">,</span>  
   <span class="n">event_param_index</span><span class="p">,</span>  
   <span class="n">event_param_key</span><span class="p">,</span>  
   <span class="n">event_param_value</span>  
<span class="k">FROM</span>  
   <span class="n">source_events</span> <span class="n">MAIN</span>  
<span class="k">WHERE</span>  
   <span class="k">EXISTS</span> <span class="p">(</span>  
      <span class="k">SELECT</span> <span class="mi">1</span>  
      <span class="k">FROM</span> <span class="n">source_events</span> <span class="n">SUB</span>  
      <span class="k">WHERE</span>  
         <span class="n">event_type</span> <span class="o">=</span> <span class="s1">'click_button'</span>  
         <span class="k">AND</span> <span class="n">MAIN</span><span class="p">.</span><span class="n">user_id</span> <span class="o">=</span> <span class="n">SUB</span><span class="p">.</span><span class="n">user_id</span>  
         <span class="k">AND</span> <span class="n">MAIN</span><span class="p">.</span><span class="n">session_id</span> <span class="o">=</span> <span class="n">SUB</span><span class="p">.</span><span class="n">session_id</span>  
         <span class="k">AND</span> <span class="n">MAIN</span><span class="p">.</span><span class="n">event_index</span> <span class="o">=</span> <span class="n">SUB</span><span class="p">.</span><span class="n">event_index</span>  
         <span class="k">AND</span> <span class="p">(</span>  
            <span class="n">MAIN</span><span class="p">.</span><span class="n">event_param_index</span> <span class="o">=</span> <span class="n">SUB</span><span class="p">.</span><span class="n">event_param_index</span> <span class="o">+</span> <span class="mi">0</span>  
            <span class="k">OR</span> <span class="n">MAIN</span><span class="p">.</span><span class="n">event_param_index</span> <span class="o">=</span> <span class="n">SUB</span><span class="p">.</span><span class="n">event_param_index</span> <span class="o">+</span> <span class="mi">1</span>  
            <span class="k">OR</span> <span class="n">MAIN</span><span class="p">.</span><span class="n">event_param_index</span> <span class="o">=</span> <span class="n">SUB</span><span class="p">.</span><span class="n">event_param_index</span> <span class="o">+</span> <span class="mi">2</span>  
            <span class="k">OR</span> <span class="n">MAIN</span><span class="p">.</span><span class="n">event_param_index</span> <span class="o">=</span> <span class="n">SUB</span><span class="p">.</span><span class="n">event_param_index</span> <span class="o">+</span> <span class="mi">3</span>  
         <span class="p">)</span>  
   <span class="p">)</span>
</code></pre></div></div>

<p>자, 어떻게 달라졌는지 차근차근 살펴보도록 하죠.</p>

<h3 id="1-먼저-left-join이-사라지고-where-statement의-subquery가-추가되었습니다">1. 먼저, LEFT JOIN이 사라지고, WHERE Statement의 Subquery가 추가되었습니다.</h3>

<p>JOIN보다 Subquery가 반드시 모든 상황에서 성능이 우월하지는 않지만, 이 상황에서는 메모리 데이터의 사이즈는 상당 부분 해소되었습니다. 앞서 말씀 드린 것처럼, SQL은 WHERE Statement를 고려하기 전에 먼저 FROM과 LEFT JOIN을 먼저 실행하게 되는데, WHERE Statement의 Subquery로 옮김으로써 LEFT JOIN에서 실행되어야 하는 작업을 WHERE에서 동시에 연산하여 메모리에 올릴 수 있게 되었습니다.</p>

<p>가령,  <code class="language-plaintext highlighter-rouge">source_events</code>  테이블의 Row 수가 1,000,000개 이고, WHERE를 통해 Filter out된 Row 수가 10,000개라면, 메모리에 올라가게 되는 Row 수는 이전의 최대 1,000,000 * 1,000,000개에서 1,000,000 * 10,000개로 1% 수준으로 급감하였습니다.</p>

<h3 id="2-in보다-exists가-연산-속도가-더-빠릅니다">2. IN보다 EXISTS가 연산 속도가 더 빠릅니다.</h3>

<p>IN과 EXISTS 모두 “<strong>XXX한 경우가 존재하니?</strong>”를 질문하는 과정으로 추상화할 수 있을 것 같은데요.</p>

<p>만약 IN을 통해 Filter out하려고 하면 가령 아래와 같은 쿼리문을 작성해야 합니다.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">WHERE</span>  
   <span class="n">MAIN</span><span class="p">.</span><span class="n">event_param_index</span> <span class="k">IN</span> <span class="p">(</span><span class="k">SELECT</span> <span class="n">SUB</span><span class="p">.</span><span class="n">event_param_index</span> <span class="o">+</span> <span class="mi">0</span> <span class="k">FROM</span> <span class="p">...)</span>  
   <span class="k">AND</span> <span class="n">MAIN</span><span class="p">.</span><span class="n">event_param_index</span> <span class="k">IN</span> <span class="p">(</span><span class="k">SELECT</span> <span class="n">SUB</span><span class="p">.</span><span class="n">event_param_index</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">FROM</span> <span class="p">...)</span>  
   <span class="k">AND</span> <span class="n">MAIN</span><span class="p">.</span><span class="n">event_param_index</span> <span class="k">IN</span> <span class="p">(</span><span class="k">SELECT</span> <span class="n">SUB</span><span class="p">.</span><span class="n">event_param_index</span> <span class="o">+</span> <span class="mi">2</span> <span class="k">FROM</span> <span class="p">...)</span>  
   <span class="k">AND</span> <span class="n">MAIN</span><span class="p">.</span><span class="n">event_param_index</span> <span class="k">IN</span> <span class="p">(</span><span class="k">SELECT</span> <span class="n">SUB</span><span class="p">.</span><span class="n">event_param_index</span> <span class="o">+</span> <span class="mi">3</span> <span class="k">FROM</span> <span class="p">...)</span>  
<span class="p">...</span>
</code></pre></div></div>

<p>위 과정은 한 가지 단점이 있습니다.  <code class="language-plaintext highlighter-rouge">SUB.event_param_index</code>  칼럼의 값들을 일일이 출력해야 하는데요. 즉, 다양한 값들로 구성된 칼럼을 메모리에 로드해야 한다는 것이죠.</p>

<p>그러나 EXISTS를 통해 Filter out하려고 하면 아래와 같은 쿼리문으로 수정될 수 있습니다.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">WHERE</span>  
   <span class="k">EXISTS</span> <span class="p">(</span>  
      <span class="k">SELECT</span> <span class="mi">1</span>  
      <span class="k">FROM</span> <span class="p">...</span>  
      <span class="k">WHERE</span>  
         <span class="p">...</span>  
         <span class="k">AND</span> <span class="p">(</span>  
         <span class="n">MAIN</span><span class="p">.</span><span class="n">event_param_index</span> <span class="o">=</span> <span class="n">SUB</span><span class="p">.</span><span class="n">event_param_index</span> <span class="o">+</span> <span class="mi">0</span>  
         <span class="k">OR</span> <span class="n">MAIN</span><span class="p">.</span><span class="n">event_param_index</span> <span class="o">=</span> <span class="n">SUB</span><span class="p">.</span><span class="n">event_param_index</span> <span class="o">+</span> <span class="mi">1</span>  
         <span class="k">OR</span> <span class="n">MAIN</span><span class="p">.</span><span class="n">event_param_index</span> <span class="o">=</span> <span class="n">SUB</span><span class="p">.</span><span class="n">event_param_index</span> <span class="o">+</span> <span class="mi">2</span>  
         <span class="k">OR</span> <span class="n">MAIN</span><span class="p">.</span><span class="n">event_param_index</span> <span class="o">=</span> <span class="n">SUB</span><span class="p">.</span><span class="n">event_param_index</span> <span class="o">+</span> <span class="mi">3</span>  
   <span class="p">)</span>
</code></pre></div></div>

<p>이 과정은 위에서 말씀 드린 IN의 단점을 상당 부분 해소합니다.  <code class="language-plaintext highlighter-rouge">SUB.event_param_index</code>  칼럼의 값들을 일일이 출력했던 것과 달리, 이번에는 조건을 만족하기만 하면 단순히 일괄적으로  <code class="language-plaintext highlighter-rouge">1</code>로만 구성된 칼럼을 메모리에 로드하게 됩니다. Data Type 측면에서 훨씬 메모리의 부담을 경감시킬 수 있습니다. (혹은 <code class="language-plaintext highlighter-rouge">1</code>이 아니라,  <code class="language-plaintext highlighter-rouge">True</code>나  <code class="language-plaintext highlighter-rouge">False</code>와 같은 Boolean 타입으로 출력하면 더 확실하게 경감시킬 수 있을 것 같네요.)</p>

<h1 id="5-결론-무조건적-우월성은-없다">5. 결론: 무조건적 우월성은 없다.</h1>

<p>자 이제 다시 최적화된 쿼리문 전체를 보시죠.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span>  
   <span class="nb">datetime</span><span class="p">,</span>  
   <span class="n">user_id</span><span class="p">,</span>  
   <span class="n">session_id</span><span class="p">,</span>  
   <span class="n">event_index</span><span class="p">,</span>  
   <span class="n">event_param_index</span><span class="p">,</span>  
   <span class="n">event_param_key</span><span class="p">,</span>  
   <span class="n">event_param_value</span>  
<span class="k">FROM</span>  
   <span class="n">source_events</span> <span class="n">MAIN</span>  
<span class="k">WHERE</span>  
   <span class="k">EXISTS</span> <span class="p">(</span>  
      <span class="k">SELECT</span> <span class="mi">1</span>  
      <span class="k">FROM</span> <span class="n">source_events</span> <span class="n">SUB</span>  
      <span class="k">WHERE</span>  
         <span class="n">event_type</span> <span class="o">=</span> <span class="s1">'click_button'</span>  
         <span class="k">AND</span> <span class="n">MAIN</span><span class="p">.</span><span class="n">user_id</span> <span class="o">=</span> <span class="n">SUB</span><span class="p">.</span><span class="n">user_id</span>  
         <span class="k">AND</span> <span class="n">MAIN</span><span class="p">.</span><span class="n">session_id</span> <span class="o">=</span> <span class="n">SUB</span><span class="p">.</span><span class="n">session_id</span>  
         <span class="k">AND</span> <span class="n">MAIN</span><span class="p">.</span><span class="n">event_index</span> <span class="o">=</span> <span class="n">SUB</span><span class="p">.</span><span class="n">event_index</span>  
         <span class="k">AND</span> <span class="p">(</span>  
            <span class="n">MAIN</span><span class="p">.</span><span class="n">event_param_index</span> <span class="o">=</span> <span class="n">SUB</span><span class="p">.</span><span class="n">event_param_index</span> <span class="o">+</span> <span class="mi">0</span>  
            <span class="k">OR</span> <span class="n">MAIN</span><span class="p">.</span><span class="n">event_param_index</span> <span class="o">=</span> <span class="n">SUB</span><span class="p">.</span><span class="n">event_param_index</span> <span class="o">+</span> <span class="mi">1</span>  
            <span class="k">OR</span> <span class="n">MAIN</span><span class="p">.</span><span class="n">event_param_index</span> <span class="o">=</span> <span class="n">SUB</span><span class="p">.</span><span class="n">event_param_index</span> <span class="o">+</span> <span class="mi">2</span>  
            <span class="k">OR</span> <span class="n">MAIN</span><span class="p">.</span><span class="n">event_param_index</span> <span class="o">=</span> <span class="n">SUB</span><span class="p">.</span><span class="n">event_param_index</span> <span class="o">+</span> <span class="mi">3</span>  
         <span class="p">)</span>  
   <span class="p">)</span>
</code></pre></div></div>

<p>프로그래밍에는 반드시 “<strong>방법 A가 방법 B보다 우월하다.</strong>”라는 것은 존재하지 않은 것처럼, 각자의 환경에 따라 취사선택하며 최적화를 하는 것이 중요할 것입니다.</p>

<p>WHERE Statement의 Subquery가 JOIN보다 반드시 우월한 것도 아니고, 경우에 따라 EXISTS가 IN보다 반드시 뛰어난 성능을 보이지 않을 수도 있습니다.</p>

<p>또한, 일반적으로 Subquery와 EXISTS 문법은 SQL 초급 사용자 분들께는 살짝 팔로업하기 어려울 수 있으므로, 가독성 측면에서 추후 유지보수의 장애로 작용할 수도 있을 것입니다.</p>

<p><img src="/assets/2023-11-30-how-to-avoid-self-joins/infinite-challenge.webp" alt="" /></p>
<blockquote>
  <p><a href="https://i.pinimg.com/736x/cd/c3/57/cdc35735e9efc721d26a0f3f780178a4.jpg">Source</a></p>
</blockquote>

<p>앞으로, 대용량의 데이터 소스를 다루시다가 SELF JOIN 때문에 트래픽 문제가 발생하신다면 위와 같은 사례로도 접근 가능하다는 점을 참고하시고, 각자 처한 환경에 따라 최적화하여 가성비 좋은 데이터 분석을 하시길 바랄게요. 부족한 글을 읽어주셔서 감사합니다!</p>

<p><img src="/assets/2023-11-30-how-to-avoid-self-joins/bye-guys.webp" alt="" /></p>
<blockquote>
  <p>퇴사하겠다는 의미가 아니라, 계속 쿼리 작성하러 가겠다는 의미</p>
</blockquote>

<hr />

<h2 id="published-by-joshua-kim"><em>Published by</em> Joshua Kim</h2>
<p><img src="/assets/profile/joshua-profile.png" alt="Joshua Kim" /></p>]]></content><author><name></name></author><category term="Data Analysis" /><category term="SQL" /><summary type="html"><![CDATA[대고객 서빙을 위해 엄청나게 큰 사이즈의 소스 테이블로부터 최적화된 데이터 마트 설계 고민을 많이 하고 있는 만큼, 이번에는 SELF JOIN 사례를 중심으로 SQL 성능에 대한 이야기를 들려드리겠습니다.]]></summary></entry></feed>